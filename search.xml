<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021，以最努力的姿态，继续前行</title>
    <url>/2021/02/12/2021-yi-zui-nu-li-de-zi-tai-ji-xu-qian-xing/</url>
    <content><![CDATA[<h1 id="2021，以最努力的姿态，继续前行"><a href="#2021，以最努力的姿态，继续前行" class="headerlink" title="2021，以最努力的姿态，继续前行"></a>2021，以最努力的姿态，继续前行</h1><blockquote>
<p>转载自<a href="https://mp.weixin.qq.com/s?__biz=MjM5NzExMzU2MA==&amp;mid=2658488176&amp;idx=1&amp;sn=d38257a0323d6f191f16aecaeabc15d9&amp;chksm=bd5f14c78a289dd1a9fe40be0f661ef9c45489ee3d29af3e8d6900e838467656eef5303d102f&amp;mpshare=1&amp;scene=23&amp;srcid=0212DZ7WSngPEbHDQtBVjZkW&amp;sharer_sharetime=1613128277381&amp;sharer_shareid=62c7a75c7277bb071a71ad78654d4e81#rd">句子迷</a>，略有修改。</p>
</blockquote>
<h3 id="你好，2021"><a href="#你好，2021" class="headerlink" title="你好，2021"></a>你好，2021</h3><h3 id="为自己加油，送给正在努力的你"><a href="#为自己加油，送给正在努力的你" class="headerlink" title="为自己加油，送给正在努力的你"></a>为自己加油，送给正在努力的你</h3><p>时间，卯足了劲儿似的飞跃到2021年，是时候告别浮躁，告别懈怠，以最努力的姿态，继续前行。只要一直在路上就没有到不了的远方。让我们用最美好的心情，迎接2021吧！</p>
<p><img src="/images/2021wishes/1.jpg"></p>
<h4 id="给正在奋斗的你"><a href="#给正在奋斗的你" class="headerlink" title="给正在奋斗的你"></a>给正在奋斗的你</h4><p>你正在为自己的未来打拼，也许有时候会感觉看不到尽头。但你要相信，渡过了这一段努力的自己都能感动自己的日子之后，你想要的，岁月统统都会还给你。任何值得去的地方，都没有捷径。</p>
<p><img src="/images/2021wishes/5.jpg"></p>
<h4 id="给略觉失意的你"><a href="#给略觉失意的你" class="headerlink" title="给略觉失意的你"></a>给略觉失意的你</h4><p>人生会经历三次成长：第一次是发现自己不是世界的中心；第二次是发现即使再怎么努力，终究还是有些事令人无能为力；第三次是在明知道有些事可能会无能为力，但还是会竭尽全力。</p>
<p><img src="/images/2021wishes/6.jpg"></p>
<h4 id="给正在迷茫的你"><a href="#给正在迷茫的你" class="headerlink" title="给正在迷茫的你"></a>给正在迷茫的你</h4><p>所谓迷茫，就是才华配不上梦想：大事干不了，小事不肯干；不想做手边的小事，只想做天边的大事。但你必须知道，小事不肯干，大事也轮不到你，趁你跌倒还能站起来的时候，先学会脚踏实地。</p>
<p><img src="/images/2021wishes/2.jpg"></p>
<h4 id="给重度拖延的你"><a href="#给重度拖延的你" class="headerlink" title="给重度拖延的你"></a>给重度拖延的你</h4><p>你总是把梦想留在未来，旅行留在下一次，想做的事留在以后，然后本该是未来的时间点，你突然被没时间打败了。所有的理由不过是你给拖延和懒惰找的借口。世界上根本没有浪费时间这回事，你唯一浪费的不过是你自己。</p>
<p><img src="/images/2021wishes/4.jpg"></p>
<h4 id="给感到孤独的你"><a href="#给感到孤独的你" class="headerlink" title="给感到孤独的你"></a>给感到孤独的你</h4><p>生活不会按你想要的方式进行。它会给你一段时间，让你孤独、迷茫又沉默。如果你用这些时间，跟自己独处，多看一本书，去做可以的事，等你度过低潮，那些独处的时光必定照亮你的路。</p>
<p><img src="/images/2021wishes/7.jpg"></p>
<h4 id="给等待爱情的你"><a href="#给等待爱情的你" class="headerlink" title="给等待爱情的你"></a>给等待爱情的你</h4><p>好的爱情是你通过一个人看到世界，坏的爱情是你为一个人舍弃世界。不必因为寂寞而凑合着恋爱，要相信，属于你的总会到来。试着让自己变得更丰盛、更强大。不必害怕，岁月有的是时间让你遇到更好 的人。</p>
<p><img src="/images/2021wishes/3.jpg"></p>
<p><strong>曾经荒废的时光，没时间遗憾，唯有追赶和改变。最痛苦的不是失败的泪水，而是不曾尽力的懊悔。别让明天的你，讨厌今天的自己。而每一个今日，都是你曾经幻想的明天。所以，请为这个今天而努力！在2021年，用你的左右脚左右世界！</strong></p>
]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>祝福</tag>
      </tags>
  </entry>
  <entry>
    <title>几种常见的颜色空间</title>
    <url>/2020/08/17/colorspace/</url>
    <content><![CDATA[<h1 id="颜色空间"><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h1><p><strong>在计算机视觉，尤其颜色识别相关的算法中，rgb,hsv,lab颜色空间混用更是常用的方法。</strong></p>
<h2 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>​    RGB颜色空间以R(Red:红)、G(Green:绿)、B(Blue:蓝)三种基本色为基础，进行不同程度的叠加，产生丰富而广泛的颜色，所以俗称三基色模式。在大自然中有无穷多种不同的颜色，而人眼只能分辨有限种不同的颜色，RGB模式可表示一千六百多万种不同的颜色，在人眼看来它非常接近大自然的颜色，故又称为自然色彩模式。红绿蓝代表可见光谱中的三种基本颜色或称为三原色，每一种颜色按其亮度的不同分为256个等级。当色光三原色重叠时，由于不同的混色比例能产生各种中间色，例如，三原色相加可产生白色。所以RGB模式是加色过程。屏幕显示的基础是RGB模式，彩色印刷品却无法用RGB模式来产生各种彩色，所以，<strong>RGB模式常用于视频、多媒体与网页设计</strong>。</p>
<h3 id="空间模型"><a href="#空间模型" class="headerlink" title="空间模型"></a>空间模型</h3><p>​    对图像处理而言，RGB是最为重要和常见的颜色模型，它建立在笛卡尔坐标系中，以红、绿、蓝三种基本色为基础，<strong>进行不同程度的叠加</strong>，产生丰富而广泛的颜色，俗称三基色模式。如下图所示：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9nc3MwLmJkc3RhdGljLmNvbS85NG8zZFNhZ194STRraEdrcG9XSzFIRjZoaHkvYmFpa2UvYzAlM0RiYWlrZTgwJTJDNSUyQzUlMkM4MCUyQzI2L3NpZ249MjdmYjUwZjlhYWVjMDhmYTMyMGQxYmY1Mzg4NzU2MDgvZTFmZTk5MjViYzMxNWM2MGU0NTA5ZmE5ODdiMWNiMTM0ODU0NzdhYi5qcGc?x-oss-process=image/format,png"></p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>​    RGB模型的原理来自于颜色的三刺激理论，它基于以下假设:在眼睛的中央部位有3种类型的对色彩敏感的锥状细胞。其中一类对位于可见光谱中间位置的光波敏感，这种光波经人的视觉系统转换产生绿色感。而其他两种锥状细胞对位于可见光波的上、下端即较长和较短的波长的光波敏感，它们分别被识别为红色和蓝色。从生理学的角度来看，由于眼睛仅包含3种不同类型的锥状细胞，因而对任意3种颜色适当混合均可产生白光视觉，条件是这3中颜色中任意两种的组合都并不能产生第3种颜色，则这三种颜色就被称为三原色。</p>
<h3 id="表达方式"><a href="#表达方式" class="headerlink" title="表达方式"></a>表达方式</h3><p>​     RGB空间是目前最常用的彩色信息表达方式，使用红、绿、蓝三原色的亮度来定量表示颜色，<strong>是以RGB三色光互相叠加来实现混色的方式</strong>。三种颜色所占比例不同，得到的颜色就不同。变换混合的比例，就会得到各种各样的混合效果。RGB颜色空间可以看作是三维直角坐标系中的一个单位正方体。任何一种颜色在RGB颜色空间中都可以用三维空间中的一个点来表示。在RGB颜色空间，任意色光F都可以用RGB三种颜色不同分量的相加混合而成：F=r[R]+g[G]+b[B]</p>
<h4 id="色度学规则："><a href="#色度学规则：" class="headerlink" title="色度学规则："></a>色度学规则：</h4><p> 　(1)通过R,G,B这三种颜色能产生任何颜色，并且这三种颜色混合后产生的颜色是唯一的。<br> 　(2)如果两个颜色相等，这三个颜色分量再乘以或者除以相同的数，得到的颜色仍然相等。<br> 　(3)混合色的亮度等于每种颜色亮度的和。</p>
<h3 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><p>​    优点： RGB颜色空间最大的优点就是直观，容易理解。</p>
<p>​    缺点：<strong>R,G,B这3个分量是高度相关的</strong>，即如果一个颜色的某一个分量发生了一定程度的改变，那么这个颜色很可能要发生改变；人眼对于常见的红绿蓝三色的敏感程度是不一样的，因此RGB颜色空间的均匀性非常差，且两种颜色之间的知觉差异色差不能表示为该颜色空间中两点间的距离，但是利用线性或非线性变换，则可以从RGB颜色空间推导出其他的颜色特征空间。</p>
<h2 id="HSV"><a href="#HSV" class="headerlink" title="HSV"></a>HSV</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>   HSV(Hue, Saturation, Value)是根据颜色的直观特性由A. R.  Smith在1978年创建的一种颜色空间, 也称六角锥体模型(Hexcone  Model)。这个模型中颜色的参数分别是：<strong>色调（H），饱和度（S），明度（V）</strong>。</p>
<h3 id="空间模型-1"><a href="#空间模型-1" class="headerlink" title="空间模型"></a>空间模型</h3><h4 id="色调H："><a href="#色调H：" class="headerlink" title="色调H："></a>色调H：</h4><p>​    用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°。它们的补色是：黄色为60°，青色为180°,品红为300°；</p>
<h4 id="饱和度S："><a href="#饱和度S：" class="headerlink" title="饱和度S："></a>饱和度S：</h4><p>   饱和度S表示颜色接近光谱色的程度。一种颜色，可以看成是某种光谱色与白色混合的结果。其中光谱色所占的比例愈大，颜色接近光谱色的程度就愈高，颜色的饱和度也就愈高。饱和度高，颜色则深而艳。光谱色的白光成分为0，饱和度达到最高。通常取值范围为0%～100%，值越大，颜色越饱和。</p>
<h4 id="明度V："><a href="#明度V：" class="headerlink" title="明度V："></a>明度V：</h4><p>明度表示颜色明亮的程度，对于光源色，明度值与发光体的光亮度有关；对于物体色，此值和物体的透射比或反射比有关。通常取值范围为0%（黑）到100%（白）。</p>
<p><strong>RGB和CMY颜色模型都是面向硬件的，而HSV（Hue Saturation  Value）颜色模型是面向用户的。</strong>HSV模型的三维表示从RGB立方体演化而来。设想从RGB沿立方体对角线的白色顶点向黑色顶点观察，就可以看到立方体的六边形外形。六边形边界表示色彩，水平轴表示纯度，明度沿垂直轴测量。</p>
<p> <img src="https://img-blog.csdnimg.cn/20181128220932509.png"> </p>
<p> <img src="https://img-blog.csdnimg.cn/20181128220957174.png"></p>
<h3 id="从RGB到HSV的转换"><a href="#从RGB到HSV的转换" class="headerlink" title="从RGB到HSV的转换"></a>从RGB到HSV的转换</h3><p>​    HSV 在数学上定义为在 RGB 空间中的颜色的 R, G 和 B 的坐标的变换。设 (r, g, b) 分别是一个颜色的红、绿和蓝坐标，它们的值是在 0 到 1 之间的实数。设 max 等价于 r, g 和 b 中的最大者，设 min 等于这些值中的最小者。要找到在 HSV 空间中的 (h, s, v) 值，这里的 h ∈ [0,  360）是角度的色相角，而 s, v ∈ [0,1] 是饱和度和亮度，计算公式为：</p>
<p><img src="https://img-blog.csdnimg.cn/20181128221242343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppYW5nSHVpMTIxMQ==,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://img-blog.csdnimg.cn/20181128221304329.png"></p>
<p><img src="https://img-blog.csdnimg.cn/2018112822132243.png"></p>
<p>​    HSV对用户来说是一种直观的颜色模型。我们可以从一种纯色彩开始，即指定色彩角H，并让V=S=1，然后我们可以通过向其中加入黑色和白色来得到我们需要的颜色。<strong>增加黑色可以减小V而S不变，同样增加白色可以减小S而V不变。</strong>例如，要得到深蓝色，V=0.4 S=1 H=240度。要得到淡蓝色，V=1 S=0.4 H=240度。</p>
<p>   一般说来，人眼最大能区分128种不同的色彩，130种色饱和度，23种明暗度。如果我们用16Bit表示HSV的话，可以用7位存放H，4位存放S，5位存放V，即745或者655就可以满足我们的需要了。</p>
<p>​    由于HSV是一种比较直观的颜色模型，所以在许多图像编辑工具中应用比较广泛，如Photoshop（在Photoshop中叫HSB）等等，但这也决定了<strong>它不适合使用在光照模型中，许多光线混合运算、光强运算等都无法直接使用HSV来实现。</strong></p>
<h2 id="LAB"><a href="#LAB" class="headerlink" title="LAB"></a>LAB</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p>​     <a href="https://baike.baidu.com/item/Lab%E6%A8%A1%E5%BC%8F/7362402">Lab模式</a>是根据Commission International Eclairage（CIE）在1931年所制定的一种测定颜色的国际标准建立的。于1976年被改进，并且命名的一种色彩模式。Lab颜色模型弥补了<a href="https://baike.baidu.com/item/RGB/342517">RGB</a>和CMYK两种色彩模式的不足。它是一种<strong>设备无关的颜色模型</strong>，也是一种<strong>基于生理特征的颜色模型</strong>。 Lab颜色模型由三个要素组成，一个要素是亮度（L），a 和b是两个<a href="https://baike.baidu.com/item/%E9%A2%9C%E8%89%B2%E9%80%9A%E9%81%93/5706858">颜色通道</a>。a包括的颜色是从<a href="https://baike.baidu.com/item/%E6%B7%B1%E7%BB%BF%E8%89%B2/2192808">深绿色</a>（低亮度值）到灰色（中亮度值）再到亮粉红色（高亮度值）；b是从亮蓝色（低亮度值）到灰色（中亮度值）再到黄色（高亮度值）。因此，这种颜色混合后将产生具有明亮效果的色彩。</p>
<h3 id="空间模型-2"><a href="#空间模型-2" class="headerlink" title="空间模型"></a>空间模型</h3><p>​    <a href="https://baike.baidu.com/item/Lab%E6%A8%A1%E5%BC%8F/7362402">Lab模式</a>既不依赖光线，也不依赖于颜料，它是CIE组织确定的一个理论上包括了人眼可以看见的所有色彩的色彩模式。Lab模式弥补了<a href="https://baike.baidu.com/item/RGB/342517">RGB</a>和CMYK两种色彩模式的不足。同RGB颜色空间相比，Lab是一种不常用的色彩空间。它是一种设备无关的颜色系统，也是一种基于生理特征的颜色系统。这也就意味着，<strong>它是用数字化的方法来描述人的视觉感应</strong>。Lab颜色空间中的L分量用于表示像素的亮度，取值范围是[0,100],表示从纯黑到纯白；a表示从红色到绿色的范围，取值范围是[127,-128]；b表示从黄色到蓝色的范围，取值范围是[127,-128]。下图所示为Lab颜色空间的图示：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9nc3MzLmJkc3RhdGljLmNvbS8tUG8zZFNhZ194STRraEdrcG9XSzFIRjZoaHkvYmFpa2UvYzAlM0RiYWlrZTgwJTJDNSUyQzUlMkM4MCUyQzI2L3NpZ249ZTM1OWY1YTZhNDRiZDExMzEwYzBiZjYwM2JjNmNmNmEvMDIzYjViYjVjOWVhMTVjZTFkMWZmMWRjYmYwMDNhZjMzYjg3YjI3NS5qcGc?x-oss-process=image/format,png"></p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>​     <strong>Lab颜色空间比计算机显示器甚至比人类视觉的色域都要大 **，表示为Lab的位图比RGB或CMYK位图获得同样的精度需要要求更多的像素数据。<a href="https://baike.baidu.com/item/Lab%E6%A8%A1%E5%BC%8F/7362402">Lab模式</a>所定义的色彩最多，且与光线及设备无关并且</strong>处理速度与<a href="https://baike.baidu.com/item/RGB%E6%A8%A1%E5%BC%8F/7362104">RGB模式</a>同样快**，比<a href="https://baike.baidu.com/item/CMYK%E6%A8%A1%E5%BC%8F/305545">CMYK模式</a>快很多。因此，可以放心大胆的在图象编辑中使用Lab模 式。而且，Lab模式在转换成CMYK模式时色彩没有丢失或被替换。因此，最佳避免色彩损失的方法是：应用Lab模式编辑图象，再转换为CMYK模式打印 输出。</p>
<h2 id="CMYK"><a href="#CMYK" class="headerlink" title="CMYK"></a>CMYK</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><p>​    当阳光照射到一个物体上时，这个物体将吸收一部分光线，并将剩下的光线进行反射，反射的光线就是我们所看见的物体颜色。这是一种**减色<a href="https://baike.baidu.com/item/%E8%89%B2%E5%BD%A9%E6%A8%A1%E5%BC%8F/10209468">色彩模式</a>**，同时也是与<a href="https://baike.baidu.com/item/RGB%E6%A8%A1%E5%BC%8F">RGB模式</a>的根本不同之处。不但我们看物体的颜色时用到了这种减色模式，而且在纸上印刷时应用的也是这种减色模式。CMYK代表印刷上用的四种颜色，C代表青色（Cyan），M代表<a href="https://baike.baidu.com/item/%E6%B4%8B%E7%BA%A2%E8%89%B2/6833575">洋红色</a>（Magenta），Y代表黄色（Yellow），K代表黑色（Black）。因为在实际应用中，青色、洋红色和黄色很难叠加形成真正的黑色，最多不过是褐色而已。因此才引入了K——黑色。黑色的作用是强化暗调，加深暗部色彩。</p>
<h3 id="打印模式"><a href="#打印模式" class="headerlink" title="打印模式"></a>打印模式</h3><p>​     <strong>CMYK模式俗称四色打印模式，是最佳的打印模式</strong>。但是在进行实际打印时，两种模式存在转换问题，具体原因如下：</p>
<p>​     1. CMYK模式编辑虽然能够避免色彩的损失，但运算速度很慢。主要原因如下：</p>
<p>​        1）、即使在CMYK模式下工作，<a href="https://baike.baidu.com/item/Photoshop/133866">Photoshop</a>也必须将CMYK模式转变为显示器所使用的RGB模式。</p>
<p>​        2）、对于同样的图像，RGB模式只需要处理三个<a href="https://baike.baidu.com/item/%E9%80%9A%E9%81%93">通道</a>即可，而CMYK模式则需要处理四个。</p>
<p>​     2.  用户所使用的扫描仪和显示器都是<a href="https://baike.baidu.com/item/RGB/342517">RGB</a>设备，所以无论什么时候使用CMYK模式工作都有把RGB模式转换为CMYK模式这样一个过程。因此，是否应用CMYK模式进行编辑都存在<a href="https://baike.baidu.com/item/RGB%E6%A8%A1%E5%BC%8F/7362104">RGB模式</a>和CMYK模式转换的问题。</p>
<p>​    对于<a href="https://baike.baidu.com/item/RGB%E6%A8%A1%E5%BC%8F/7362104">RGB模式</a>和CMYK模式转换的问题，可以先用RGB模式进行编辑工作，再用CMYK模式进行打印工作，在打印前才进行转换，然后加入必要的<a href="https://baike.baidu.com/item/%E8%89%B2%E5%BD%A9%E6%A0%A1%E6%AD%A3/10786529">色彩校正</a>，<a href="https://baike.baidu.com/item/%E9%94%90%E5%8C%96/2189784">锐化</a>和修整。这样虽然使<a href="https://baike.baidu.com/item/Photoshop/133866">Photoshop</a>在CMYK模式下速度慢一些，但可节省大部分编辑时间。这种打印前的模式转换，并不是避免图像损失最佳的途径，最佳方法是将<a href="https://baike.baidu.com/item/Lab%E6%A8%A1%E5%BC%8F">Lab模式</a>和CMYK模式相结合使用，这样可以最大程度的减少图像失真。</p>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>   优点：可以满足打印的需求，解决RGB不能打印的问题</p>
<p>   缺点：一定程度上存在色彩的缺失，运行速度慢</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV-Notes</title>
    <url>/2021/02/24/opencv-notes/</url>
    <content><![CDATA[<h1 id="OpenCV-Notes"><a href="#OpenCV-Notes" class="headerlink" title="OpenCV-Notes"></a>OpenCV-Notes</h1><h2 id="计算某一个算法的帧率"><a href="#计算某一个算法的帧率" class="headerlink" title="计算某一个算法的帧率"></a>计算某一个算法的帧率</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Start timer
double timer = (double) getTickCount();

//待测算法
algorithm();

// Calculate Frames per second (FPS)
float fps = getTickFrequency() / ((double) getTickCount() - timer);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="使用putText-函数将信息直接输出到图片上"><a href="#使用putText-函数将信息直接输出到图片上" class="headerlink" title="使用putText()函数将信息直接输出到图片上"></a>使用putText()函数将信息直接输出到图片上</h2><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void cv::putText(
	cv::Mat&amp; img, // 待绘制的图像
	const string&amp; text, // 待绘制的文字
	cv::Point origin, // 文本框的左下角
	int fontFace, // 字体 (如cv::FONT_HERSHEY_PLAIN)
	double fontScale, // 尺寸因子，值越大文字越大
	cv::Scalar color, // 线条的颜色（RGB）
	int thickness = 1, // 线条宽度
	int lineType = 8, // 线型（4邻域或8邻域，默认8邻域）
	bool bottomLeftOrigin = false // true='origin at lower left'
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>在图片左上角显示使用的算法，帧率，是否检测到目标物</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">putText(frame, detectionType, Point(100, 20), FONT_HERSHEY_SIMPLEX, 0.75, Scalar(50, 170, 50), 2);

putText(frame, "FPS : " + to_string(int(fps)), Point(100, 50), FONT_HERSHEY_SIMPLEX, 0.75, Scalar(50, 170, 50), 2);

if(detection_failed)
	putText(frame, " Detection failed", Point(100, 80), FONT_HERSHEY_SIMPLEX, 0.75, Scalar(0, 0, 255), 2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面是效果图：</p>
<p><img src="/images/OpenCV-Notes/1.png"></p>
<p><img src="/images/OpenCV-Notes/2.png"></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS中nodelet的使用</title>
    <url>/2020/09/04/ros-zhong-nodelet-de-shi-yong/</url>
    <content><![CDATA[<h1 id="ROS中nodelet的使用："><a href="#ROS中nodelet的使用：" class="headerlink" title="ROS中nodelet的使用："></a>ROS中nodelet的使用：</h1><h2 id="1-为什么使用nodelet？"><a href="#1-为什么使用nodelet？" class="headerlink" title="1. 为什么使用nodelet？"></a>1. 为什么使用nodelet？</h2><p>Nodelet提供了一种方法，可以在同一台计算机上，在同一个进程内，运行多个算法，且在进程内消息传递时不产生复制成本（zero  copy）。在一个node里面，roscpp利用指针传递可以实现在publish和subscribe调用时的零拷贝。为了实现相似的效果，多个nodelets允许将多个类动态加载到同一个node里，同时还提供独立的命名空间，从而使得这些nodelets尽管运行在同一个进程里，但却仍然像单独的node一样工作。也就实现了“在一个进程（node）里运行多个nodelet”的效果。</p>
<p>因此，大通量数据流可能包含多个nodelet，此时若将他们加载到同一个进程里，就可以避免数据拷贝和网络传输。</p>
<h2 id="2-在ROS工程中使用nodelet"><a href="#2-在ROS工程中使用nodelet" class="headerlink" title="2. 在ROS工程中使用nodelet"></a>2. 在ROS工程中使用nodelet</h2><h3 id="2-1-创建工作空间和程序包"><a href="#2-1-创建工作空间和程序包" class="headerlink" title="2.1 创建工作空间和程序包"></a>2.1 创建工作空间和程序包</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p ~/catkin_ar/src

<span class="token builtin class-name">cd</span> catkin_ar/

catkin_make

<span class="token builtin class-name">source</span> devel/setup.sh

<span class="token builtin class-name">cd</span> src

catkin_create_pkg try_nodelet roscpp rospy nodelet std_msgs sensor_msgs cv_bridge image_transport ddynamic_reconfigure<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="2-2-创建并且编写cpp文件与hpp文件"><a href="#2-2-创建并且编写cpp文件与hpp文件" class="headerlink" title="2.2 创建并且编写cpp文件与hpp文件"></a>2.2 创建并且编写cpp文件与hpp文件</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//try_use.hpp
#pragma once
#include &lt;nodelet/nodelet.h&gt;
#include &lt;ros/ros.h&gt;

namespace try_nodelet
{
    class try_use : public nodelet::Nodelet
    {
    public:
        virtual void onInit();
    };
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//try_use.cpp
#include &lt;pluginlib/class_list_macros.h&gt;
#include &lt;../include/try_nodelet/try_use.hpp&gt;

PLUGINLIB_EXPORT_CLASS(try_nodelet::try_use,nodelet::Nodelet)

namespace try_nodelet
{
    void try_use::onInit()
    {
        NODELET_DEBUG("Initializing nodelet...");
        ROS_INFO("Nodelet is Ok for test!!");
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="2-3-编写nodelet-plugins-xml"><a href="#2-3-编写nodelet-plugins-xml" class="headerlink" title="2.3 编写nodelet_plugins.xml"></a>2.3 编写nodelet_plugins.xml</h3><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>library</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>lib/libtry_nodelet<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    
<span class="token comment">&lt;!--上面这个try_nodelet是包的名字，下面的那个是命名空间的名字--&gt;</span>
    
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>try_nodelet/try_use<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>try_nodelet::try_use<span class="token punctuation">"</span></span> <span class="token attr-name">base_class_type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nodelet::Nodelet<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">&gt;</span></span>
  Trying to use nodelet in ROS.
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>class</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>library</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="2-4-修改CMakeLists-txt与package-xml"><a href="#2-4-修改CMakeLists-txt与package-xml" class="headerlink" title="2.4 修改CMakeLists.txt与package.xml"></a>2.4 修改CMakeLists.txt与package.xml</h3><p>修改CMakeLists.txt</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.0.2</span><span class="token punctuation">)</span>
<span class="token keyword">project</span><span class="token punctuation">(</span>try_nodelet<span class="token punctuation">)</span>

<span class="token keyword">add_compile_options</span><span class="token punctuation">(</span>-std=c++<span class="token number">11</span><span class="token punctuation">)</span>
<span class="token comment">#上面这个最好加上，否则可能会编译失败</span>

<span class="token keyword">find_package</span><span class="token punctuation">(</span>catkin REQUIRED COMPONENTS
  cv_bridge
  ddynamic_reconfigure
  image_transport
  nodelet
  roscpp
  rospy
  sensor_msgs
  std_msgs
<span class="token punctuation">)</span>

<span class="token function">catkin_package</span><span class="token punctuation">(</span>
  INCLUDE_DIRS include
  LIBRARIES try_nodelet
  CATKIN_DEPENDS cv_bridge ddynamic_reconfigure image_transport nodelet roscpp rospy sensor_msgs std_msgs
<span class="token comment">#  DEPENDS system_lib</span>
<span class="token punctuation">)</span>

<span class="token keyword">include_directories</span><span class="token punctuation">(</span>
   include
  <span class="token punctuation">${</span>catkin_INCLUDE_DIRS<span class="token punctuation">}</span>
<span class="token punctuation">)</span>

<span class="token keyword">add_library</span><span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span> 
    src/try_use.cpp
<span class="token punctuation">)</span>

<span class="token keyword">add_dependencies</span><span class="token punctuation">(</span>
    <span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span> 
    <span class="token punctuation">${</span><span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span>_EXPORTED_TARGETS<span class="token punctuation">}</span> 
    <span class="token punctuation">${</span>catkin_EXPORTED_TARGETS<span class="token punctuation">}</span>
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改package.xml</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0"?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>package</span> <span class="token attr-name">format</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">&gt;</span></span>try_nodelet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>0.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">&gt;</span></span>The try_nodelet package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">&gt;</span></span>

  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maintainer</span> <span class="token attr-name">email</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>npu-lqx@todo.todo<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>npu-lqx<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maintainer</span><span class="token punctuation">&gt;</span></span>

  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>license</span><span class="token punctuation">&gt;</span></span>TODO<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>license</span><span class="token punctuation">&gt;</span></span>

  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>buildtool_depend</span><span class="token punctuation">&gt;</span></span>catkin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>buildtool_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">&gt;</span></span>cv_bridge<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">&gt;</span></span>ddynamic_reconfigure<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">&gt;</span></span>image_transport<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">&gt;</span></span>nodelet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">&gt;</span></span>roscpp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">&gt;</span></span>rospy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">&gt;</span></span>sensor_msgs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">&gt;</span></span>std_msgs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>cv_bridge<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>ddynamic_reconfigure<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>image_transport<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>nodelet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>roscpp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>rospy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>sensor_msgs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>std_msgs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">&gt;</span></span>cv_bridge<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">&gt;</span></span>ddynamic_reconfigure<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">&gt;</span></span>image_transport<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">&gt;</span></span>nodelet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">&gt;</span></span>roscpp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">&gt;</span></span>rospy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">&gt;</span></span>sensor_msgs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">&gt;</span></span>std_msgs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">&gt;</span></span>

  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>export</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nodelet</span> <span class="token attr-name">plugin</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${prefix}/nodelet_plugins.xml<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>export</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>package</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="3-启动ROS节点"><a href="#3-启动ROS节点" class="headerlink" title="3.启动ROS节点"></a>3.启动ROS节点</h2><h3 id="3-1-编写launch文件进行快速启动"><a href="#3-1-编写launch文件进行快速启动" class="headerlink" title="3.1 编写launch文件进行快速启动"></a>3.1 编写launch文件进行快速启动</h3><p>新建一个launch文件夹，并在文件夹中新建一个start.launch文件</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>launch</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nodelet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nodelet<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>standalone_nodelet<span class="token punctuation">"</span></span>  <span class="token attr-name">args</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>manager<span class="token punctuation">"</span></span> <span class="token attr-name">output</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>screen<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nodelet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nodelet<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>using_nodelet<span class="token punctuation">"</span></span> <span class="token attr-name">args</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>load try_nodelet/try_use standalone_nodelet<span class="token punctuation">"</span></span> <span class="token attr-name">output</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>screen<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>node</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>launch</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-2-通过命令行运行"><a href="#3-2-通过命令行运行" class="headerlink" title="3.2 通过命令行运行"></a>3.2 通过命令行运行</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#终端1</span>
roscore
<span class="token comment">#终端2</span>
rosrun nodelet nodelet manager __name:<span class="token operator">=</span>nodelet_manager
<span class="token comment">#终端3</span>
rosrun nodelet nodelet load try_nodelet/try_use nodelet_manager __name:<span class="token operator">=</span>using_nodelet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，如果这里报错“According to the loaded plugin descriptions the class try_nodelet/try_use with base class type nodelet::Nodelet does not exist.”  一般是因为运行manager的窗口（终端2）没有source</p>
<p>所以要么一开始就把source写进配置文件中，要么就每个相关的窗口都要source，这样能够避免很多问题，也方便自己找到程序的bug所在。</p>
<h2 id="4-将已有的ROS工程改写为nodelet"><a href="#4-将已有的ROS工程改写为nodelet" class="headerlink" title="4.将已有的ROS工程改写为nodelet"></a>4.将已有的ROS工程改写为nodelet</h2><p>待补充~</p>
]]></content>
      <categories>
        <category>ROS基础操作</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM问题的数学表述</title>
    <url>/2021/02/05/slam-wen-ti-de-shu-xue-biao-shu/</url>
    <content><![CDATA[<h1 id="SLAM问题的数学表述"><a href="#SLAM问题的数学表述" class="headerlink" title="SLAM问题的数学表述"></a>SLAM问题的数学表述</h1><blockquote>
<p>本文是作者对于SLAM问题数学表述的一些理解，如有错误，非常非常非常欢迎指正！</p>
</blockquote>
<h2 id="经典SLAM模型"><a href="#经典SLAM模型" class="headerlink" title="经典SLAM模型"></a>经典SLAM模型</h2><p>经典SLAM模型由一个<strong>运动方程</strong>和一个<strong>观测方程</strong>构成，如下所示：<br>$$<br>\begin{cases}<br>x_k &amp;= \ f(x_{k-1},u_k,w_k) \\<br>z_{k,j} &amp;= \ h(y_j,x_k,v_{k,j})<br>\end{cases}<br>$$<br>有时候也会写成下面这样的形式：<br>$$<br>\begin{cases}<br>x_k &amp;= \ f(x_{k-1},u_k) +w_k \\<br>z_{k,j} &amp;= \ h(y_j,x_k)+v_{k,j}<br>\end{cases}<br>$$<br>这两种形式本质上都是一样的。其中，$ x_k $表示第k次的位置或者位姿，$ u_k $表示第k次传感器的读数或者输入，$ w_k $表示第k次运动过程中的噪声；而$ y_j $为观测到的路标点j，$ z_{k,j} $则表示第k次观测中对于路标点j所得到的观测结果，$ v_{k,j} $为本次观测过程中的噪声。而上面的函数 $ f $ 和 $ h $ ，需要根据具体的情况来确定。</p>
<p>之后，我们将以视觉SLAM为例来更深入的理解SLAM的数学表述。</p>
<h2 id="针孔相机模型"><a href="#针孔相机模型" class="headerlink" title="针孔相机模型"></a>针孔相机模型</h2><p>考虑到视觉SLAM的传感器是相机，并且通常符合针孔相机模型。所以在继续探讨之前，我们将对针孔相机模型做一个简单的介绍。</p>
<h3 id="从相机坐标系到图像坐标系"><a href="#从相机坐标系到图像坐标系" class="headerlink" title="从相机坐标系到图像坐标系"></a>从相机坐标系到图像坐标系</h3><p>如下图，相机坐标系下的一点$ P(X, Y, Z) $，通过小孔成像在相机的物理成像平面上，记为$ P’(X’, Y’) $。</p>
<p><img src="/images/slam-notes/28.png"></p>
<p>我们能够很容易的得出以下结论：<br>$$<br>\frac Zf=- \frac X{X’}=- \frac Y{Y’}<br>$$<br>由于我们通常看到的像都是正的，并且为了公式的简洁，我们对上式加以整理，得到：<br>$$<br>X’=f \frac XZ \\<br>Y’=f \frac YZ<br>$$</p>
<h3 id="从图像坐标系到像素坐标系"><a href="#从图像坐标系到像素坐标系" class="headerlink" title="从图像坐标系到像素坐标系"></a>从图像坐标系到像素坐标系</h3><p>事实上，计算机看到的图像都是由像素构成的，从图像坐标系到像素坐标系还需要经过一次转化。这里我们记像素坐标为$ P’’(u,v) $。<br>$$<br>\begin{cases}<br>u=\alpha X’+c_x \\<br>v=\beta Y’+c_y<br>\end{cases}<br>$$<br>其中$ \alpha $和$ \beta $分别表示x轴和y轴的缩放系数，而$ c_x $和$ c_y $则表示平移量。</p>
<p>我们将之前得到的结论代入上式，可以得到：<br>$$<br>\begin{cases}<br>u=f_x\frac XZ+c_x \\<br>v=f_y\frac YZ+c_y<br>\end{cases}<br>$$<br>其矩阵形式可以表示为：<br>$$<br>\begin{pmatrix} u\\v\\1 \end{pmatrix}=\frac1Z\begin{pmatrix}f_x &amp; 0 &amp; c_x \\ 0 &amp; f_y &amp; c_y\\0 &amp; 0 &amp; 1 \end{pmatrix}<br>\begin{pmatrix}X\\Y\\Z\end{pmatrix}<br>\overset{\text{def}}{=}\frac 1ZKP<br>$$<br>但我们通常使用下面的公式来表示，它看上去更简洁：<br>$$<br>Z\begin{pmatrix} u\\v\\1 \end{pmatrix}=\begin{pmatrix}f_x &amp; 0 &amp; c_x \\ 0 &amp; f_y &amp; c_y\\0 &amp; 0 &amp; 1 \end{pmatrix}<br>\begin{pmatrix}X\\Y\\Z\end{pmatrix}<br>\overset{\text{def}}{=}KP<br>$$<br>左边的是齐次坐标，而右边的是非齐次坐标。我们把中间的矩阵称为内参数，记为K，内参通常在相机生产之后就已经固定，我们可以通过查询或者标定获得相机的内参。</p>
<h3 id="从世界坐标系到相机坐标系"><a href="#从世界坐标系到相机坐标系" class="headerlink" title="从世界坐标系到相机坐标系"></a>从世界坐标系到相机坐标系</h3><p>上面我们仅仅描述了物体从相机坐标系到像素坐标系的转化。而在SLAM中，我们通常需要设置一个世界坐标系以描述相机或机器人的位置信息。因此从物体被观测，再到获得观测结果，即物体的像素坐标，中间还有一个转化过程。我们使用如下的一个式子进行描述：<br>$$<br>ZP_{uv}=Z\begin{pmatrix} u\\v\\1 \end{pmatrix}=KP=K(RP_w+t)=KTP_w<br>$$<br>这里，$ R $是旋转矩阵，$ t $是平移矩阵，$ T= \begin{pmatrix} R &amp; t \\ 0 &amp; 1 \end{pmatrix} $。可以理解为使用世界坐标系描述的点$ P_w $经过旋转变化和平移变化，得到了使用相机坐标系描述的点$ P $。</p>
<p><strong>其中R，t 或T被称为外参，而外参正是SLAM估计的目标。</strong></p>
<h2 id="更具体的数学表述"><a href="#更具体的数学表述" class="headerlink" title="更具体的数学表述"></a>更具体的数学表述</h2><p>再回到最开始提到的运动方程和观测方程：<br>$$<br>\begin{cases}<br>x_k &amp;= \ f(x_{k-1},u_k) +w_k \\<br>z_{k,j} &amp;= \ h(y_j,x_k)+v_{k,j}<br>\end{cases}<br>$$</p>
<p>我们知道机器人有六个自由度，因此我们可以把$ x_k $理解为第k次观测时机器人的位姿，它是六维的，我们可以用向量表示，也可以使用变换矩阵表示，即上面的$ T $（可以认为当前机器人的位姿是由机器人在原点经过$ R $旋转和$ t $平移得到的）。此时运动方程描述的是机器人在第k-1次观测后，对其传感器输入$ u_k $，使机器人的位姿从$ x_{k-1} $变换到了$ x_k $，而$ w_k $则是此次运动中的噪声。</p>
<p>而我们上面讲的针孔相机模型，实际上就是视觉SLAM中的观测模型。公式中$ y_j $就是针孔相机模型中我们观测的点$ P_w $，表示世界坐标系下路标点j的坐标，而$ z_{k,j} $就是观测的最终结果——像素坐标$ P_{uv} $。$ x_k $既是机器人的位姿，实际上也是模型中的外参$ T $。$ v_{k,j} $则是此次观测中的噪声。</p>
<p>至此，我们可以用一种更具体的形式重写上面的运动方程和观测方程：<br>$$<br>\begin{cases}<br>T_k &amp;= \ f(T_{k-1},u_k) +w_k \\<br>s_j P_{uv(k,j)} &amp;= \ K(R_kP_{w(j)}+t_k)+v_{k,j}=KT_kP_{w(j)}+v_{k,j}<br>\end{cases}<br>$$<br>其中$ s_j $是路标点j到相机光心的距离。</p>
<h2 id="对SLAM问题的总结"><a href="#对SLAM问题的总结" class="headerlink" title="对SLAM问题的总结"></a>对SLAM问题的总结</h2><p>通常，由于各种复杂因素的影响，我们无法直接求解机器人实际的运动方程，也无法通过理论上的运动方程精确计算出机器人的位姿，因此我们通过求解观测方程来相对精确地计算机器人的位置信息。</p>
<p>在视觉SLAM中，这个过程可以表述为：已知相机内参$ K $，相机观测到的目标物坐标$ P_w $，目标物距离相机的距离$ s $以及它在图像上的像素坐标$ P_{uv} $，求解机器人的位姿$ T $。</p>
<p>当然，由于观测数据同样受噪声影响，最终得到的位姿也不是准确的，还需要通过一些处理来减小误差。</p>
]]></content>
      <categories>
        <category>视觉SLAM</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS中使用ddynamicReconfigure</title>
    <url>/2020/09/05/ros-zhong-shi-yong-ddynamicreconfigure/</url>
    <content><![CDATA[<h1 id="ROS中使用ddynamicReconfigure"><a href="#ROS中使用ddynamicReconfigure" class="headerlink" title="ROS中使用ddynamicReconfigure"></a>ROS中使用ddynamicReconfigure</h1><h2 id="关于ddynamicReconfigure类"><a href="#关于ddynamicReconfigure类" class="headerlink" title="关于ddynamicReconfigure类"></a>关于ddynamicReconfigure类</h2><p>The DDynamicReconfigure class allows to use ROS dynamic reconfigure without the need to write a custom cpf file, <strong>variables are registered and exposed at run time</strong>.  Modification of the variables is done through a variable pointer or through a callback function.</p>
<p>The <a href="http://docs.ros.org/kinetic/api/ddynamic_reconfigure/html/classddynamic__reconfigure_1_1DDynamicReconfigure.html">DDynamicReconfigure</a> class is the main class responsible for keeping track of parameters basic properties, values, descriptions, etc. </p>
<p>It is also responsible of handling callbacks, config change requests, description setup and config setup, and the ROS publishers and  services.</p>
<p>To operate a DDynamic instance, you must go through the following procedure:</p>
<ol>
<li>Construct a <a href="http://docs.ros.org/kinetic/api/ddynamic_reconfigure/html/classddynamic__reconfigure_1_1DDynamicReconfigure.html">DDynamicReconfigure</a> instance with proper handling.</li>
<li>Add parameters to the instance as needed with any of the “add” methods.</li>
<li>Start the ROS services with any of the “start” methods.</li>
<li>If you need to change the callback after startup you may do so using “setCallback”.</li>
<li>When you need to get any of the stored parameters, call either “get” or “at” on this instance, rather than through the callback. </li>
</ol>
<h2 id="常用函数原型-amp-解析"><a href="#常用函数原型-amp-解析" class="headerlink" title="常用函数原型&amp;解析"></a>常用函数原型&amp;解析</h2><p>registerVariable register a variable to be modified via the dynamic_reconfigure API. </p>
<p>When a change is made, <strong>it will be reflected in the variable directly.</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;
  void registerVariable(
  const std::string &amp;name, 
  T *variable,
  const std::string &amp;description = "", 
  T min = getMin&lt;T&gt;(), 
  T max = getMax&lt;T&gt;()
  );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;
  void registerEnumVariable(
  const std::string &amp;name, 
  T *variable,
  const std::string &amp;description = "",
  std::map&lt;std::string, T&gt; enum_dict = {},
  const std::string &amp;enum_description = ""
  );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p>registerVariable register a variable to be modified via the dynamic_reconfigure API. </p>
<p>When a change is made, <strong>the callback will be called with the new value.</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt;
  void registerVariable(
  const std::string &amp;name, 
  T current_value,
  const boost::function&lt;void(T value)&gt; &amp;callback,
  const std::string &amp;description = "", 
  T min = getMin&lt;T&gt;(), 
  T max = getMax&lt;T&gt;()
  );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt;
  void registerEnumVariable(
  const std::string &amp;name, 
  T current_value,
  const boost::function&lt;void(T)&gt; &amp;callback,
  const std::string &amp;description,
  std::map&lt;std::string, T&gt; enum_dict = {},
  const std::string &amp;enum_description = ""
  );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<p>publishServicesTopics <strong>starts the server</strong> once all the needed variables are registered.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void publishServicesTopics();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>关于getMin()与getMax()</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt;
inline T getMin()
{
  return std::numeric_limits&lt;T&gt;::min();
}

template &lt;&gt;
inline bool getMin()
{
  return false;
}

template &lt;&gt;
inline std::string getMin&lt;std::string&gt;()
{
  return "";
}

template &lt;typename T&gt;
inline T getMax()
{
  return std::numeric_limits&lt;T&gt;::min();
}

template &lt;&gt;
inline bool getMax()
{
  return true;
}

template &lt;&gt;
inline std::string getMax()
{
  return "";
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;ros/ros.h&gt;
#include &lt;ddynamic_reconfigure/ddynamic_reconfigure.h&gt;

int global_int;

void paramCb(int new_value)
{
   global_int = new_value;
   ROS_INFO("Param modified: %d", global_int);
}

int main(int argc, char **argv) {
    // ROS init stage
    ros::init(argc, argv, "ddynamic_tutorials");
    ros::NodeHandle nh;
    ddynamic_reconfigure::DDynamicReconfigure ddr;
    
    ddr.registerVariable&lt;int&gt;("int_param",124, boost::bind(paramCb, _1), "param description",-1000,2357);
    ddr.publishServicesTopics();
    // Now parameter can be modified from the dynamic_reconfigure GUI or other tools and the callback is called on each update
    ros::spin();
    return 0;
 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>ROS基础操作</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>C++描述符delete与override</title>
    <url>/2020/08/21/delete-yu-override/</url>
    <content><![CDATA[<h1 id="delete与override"><a href="#delete与override" class="headerlink" title="delete与override"></a>delete与override</h1><h2 id="优先使用delete关键字删除函数而非private却又不实现的函数"><a href="#优先使用delete关键字删除函数而非private却又不实现的函数" class="headerlink" title="优先使用delete关键字删除函数而非private却又不实现的函数"></a>优先使用delete关键字删除函数而非private却又不实现的函数</h2><h3 id="为什么使用delete？"><a href="#为什么使用delete？" class="headerlink" title="为什么使用delete？"></a>为什么使用delete？</h3><p>​    不想让别的开发者调用特定的函数,你只需要不声明这个函数就可以了。但有时候 C++为你声明了一些函数,如果你想阻止客户调用这些函数,就不是那么容易的事了。</p>
<p>​    这种情况只有对“特殊的成员函数”才会出现,即这个成员函数是需要的时候C++自动生成的。    </p>
<p>在C++98中阻止这类函数被使用的方法是将这些函数声明为private,并且不定义它们。</p>
<p>​    将这些函数声明为私有来阻止客户调用他们。故意不定义它们是因为,如果有函数访问这些<br>函数(通过成员函数或者友好类)在链接的时候会导致没有定义而触发的错误。</p>
<p>​    在C++11中,有一个更好的方法可以基本上实现同样的功能:用 =delete标识拷贝复制函数<br>和拷贝赋值函数为删除的函数deleted functions 。</p>
<h3 id="delete的优点"><a href="#delete的优点" class="headerlink" title="delete的优点"></a>delete的优点</h3><p>​    删除函数一个重要的优势是任何函数都可以是删除的,然而仅有成员函数才可以是私有的。</p>
<h4 id="防止普通非成员函数中的隐式转化"><a href="#防止普通非成员函数中的隐式转化" class="headerlink" title="防止普通非成员函数中的隐式转化"></a>防止普通非成员函数中的隐式转化</h4><p>​    C++继承于C意味着,很多其他类型被隐式的转换为in 类型,但是有些调用可以编译但是没有任何意义.</p>
<p>​    举个例子,加入我们有个非成员函数,以一个整数位参数,然后返回这个参数是不是幸运数字:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool isLucky(int number);

isLucky('a');
isLucky(true);
isLucky(3.5);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    如果幸运数字一定要是一个整数,我们希望能到阻止上面那种形式的调用。</p>
<p>​    完成这个任务的一个方法是为想被排除出去的类型的重载函数声明为删除的:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool isLucky(int number);

bool isLucky(char)=delete;
bool isLucky(bool)=delete;
bool isLucky(double)=delete;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    如果给float一个转换为int或者double的可能性, C++总是倾向于转化为double的。以float类型调用isLucky总是调用对应的double重载,而不是int类型的那个重载。结果就是将double类型的重载删除将会阻止float类型的调用编译。</p>
<h4 id="阻止应该被禁用的模板实现"><a href="#阻止应该被禁用的模板实现" class="headerlink" title="阻止应该被禁用的模板实现"></a>阻止应该被禁用的模板实现</h4><p>​    假设你需要使用一个内嵌指针的模板：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;
void processPointer(T* ptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​    但是在指针家族中，有两个特殊的指针。</p>
<p>一个是 void* 指针，因为没有办法对它们解析引用，递增或者递减。</p>
<p>另一个是 char* 指针，因为它们往往表示指向C类型的字符串，而不是指向独立字符的指针。</p>
<p>​    这些特殊情况经常需要特殊处理。如果希望不能以 void* 或者 char* 为参数调用该函数，只需要删除这些实现：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;&gt;
void processPointer&lt;void*&gt;(void*)=delete;

template&lt;&gt;
void processPointer&lt;void*&gt;(void*)=delete;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在，使用 void* 或者 char* 调用该函数都是无效的，但使用 const void* 或者 const char* 调用也需要是无效的， 所以这些实现也需要被删除。（略）</p>
<p>如果类内部有一个函数模板，想通过声明它们为私有来禁止某些实现，是做不到的，因为赋予一个成员函数模板的某种特殊情况下的拥有不同于模板主体的访问权限是不可能的。</p>
<p>（可以声明 void* 和 char* 的版本却不实现它们 ）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyClass
{
public:
	template&lt;typename T&gt;
	void function(T t);
private:
	template&lt;&gt;				//错误！！！
	void function(char);	
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>并且模板的特殊情况必须要写在命名空间的作用域内，而不是类的作用域内。</p>
<p>不过，这个问题对于删除函数是不存在的，它们也可以在类外被声明为是被删除的（也就是在命名空间的作用域内）</p>
<h3 id="delete的注意事项"><a href="#delete的注意事项" class="headerlink" title="delete的注意事项"></a>delete的注意事项</h3><p>​    删除的函数不能通过任何方式被使用</p>
<p>​    方便起见,删除函数被声明为公有的,而不是私有的。这样设计的原因是,当客户端程序尝试使用一个成员函数的时候, C++会在检查删除状态之前检查可访问权限。当客户端代码尝试访问一个删除的私有函数时,一些编译器仅仅会警报该函数为私有,尽管这里函数的可访问性并不本质上影响它是否可以被使用。当把私有未定义的函数改为对应的删除函数时,牢记这一点是很有意义的,因为使这个函数为公有的可以产生更易读的错误信息。</p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ol>
<li>优先使用删除函数而不是私有而不定义的函数</li>
<li>任何函数都可以被声明为删除，包括非成员函数和模板实现</li>
</ol>
<h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><h4 id="对于成员函数："><a href="#对于成员函数：" class="headerlink" title="对于成员函数："></a>对于成员函数：</h4><ol>
<li>被delete了还是可以重载的</li>
<li>被delete了，里面写个默认参数没问题</li>
<li>delete函数可以被继承的！！！（看IDE的报错）(但不能用)</li>
<li>私有的delete函数被类用户使用了会以“使用私有成员函数”的名义报错</li>
<li>delete函数不能够被定义，只能够被声明</li>
</ol>
<h4 id="对于普通函数："><a href="#对于普通函数：" class="headerlink" title="对于普通函数："></a>对于普通函数：</h4><ol>
<li>可以防止不想要的隐式转化</li>
<li>但删除一种类型的，可能会影响不止一种类型的隐式转化（会导致其他类型的不明确，ambiguous）</li>
<li>模板类的删除方式有两种，一种使用template，一种直接写出（暂时没发现会出啥问题）</li>
</ol>
<h2 id="使用override关键字声明覆盖的函数"><a href="#使用override关键字声明覆盖的函数" class="headerlink" title="使用override关键字声明覆盖的函数"></a>使用override关键字声明覆盖的函数</h2><p>在C++98中，如果要发生函数的覆盖，必须满足以下几个条件：</p>
<ul>
<li>基类中的函数必须是虚函数</li>
<li>基类和派生类中函数的名字必须完全相同（析构函数除外）</li>
<li>基类和派生类中的函数形参类型必须完全一样</li>
<li>基类和派生类中的函数的常量特性必须完全一样</li>
<li>基类和派生类中的函数返回值和异常声明必须是兼容的</li>
</ul>
<p>在C++11中，还有一条：</p>
<ul>
<li><p>基类和派生类的引用修饰符必须完全一样</p>
<p>（引用修饰符是为了实现限制成员函数仅用于左值或者右值）</p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Widget
{
public:
    void doWork() &amp;;	//只有*this为左值时，这个版本才会被调用
    void doWork() &amp;&amp;;	//只有*this为右值时，这个函数才会被调用
};

Widget makeWidget();	//工厂函数，返回右值
Widget w;				//正常对象（左值）

w.doWork();				//调用了Widget::doWork &amp;
makeWidget().doWork();	//调用了Widget::doWork &amp;&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>正是因为覆盖有这么多的要求，所以一个很小的错误都可以造成很大的偏差。并且覆盖函数中出现的错误通常还是合法的，，但它导致的结果并不是你想要的。所以当你犯了某些错误的时候，你并不能依赖于编译器对你的通知。</p>
<p>例如下面这个例子，这些代码是完全合法的，但它一个虚函数都没有被覆盖——没有任何一个派生类的函数是和基类的对应函数绑定的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class	Base{
public:
    virtual	void	mf1()	const;
    virtual	void	mf2(int	x);
    virtual	void	mf3()	&amp;;
    void	mf4()	const;
};

class	Derived:	public	Base	{
public:
    virtual	void	mf1();
    virtual	void	mf2(unsigned	int	x);
    virtual	void	mf3()	&amp;&amp;;
    void	mf4()	const;
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>提示：</p>
<ul>
<li>mf1在Base中声明常成员函数,但是在Derived中没有</li>
<li>mf2在Base中以int为参数,但是在Derived中以unsigned int为参数</li>
<li>mf3在Base中有左值修饰符,但是在Derived中是右值修饰符</li>
<li>mf4没有继承Base中的虚函数</li>
</ul>
<p>因为声明派生类的覆盖函数很重要，又如此容易出错，所以C++11提供了一种方法来显示的标明派生类中的函数是为了改写基类的版本，为其加上override声明即可。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class	Derived:	public	Base {
public:
    virtual void mf1() override;

    virtual void mf2(unsigned int x) override;

    virtual void mf3() &amp;&amp; override;

    virtual void mf4() const override;
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样，上面这些代码就无法通过编译了，并且编译器会把覆盖函数所有的问题揭露出来。</p>
<h3 id="扩展：-1"><a href="#扩展：-1" class="headerlink" title="扩展："></a>扩展：</h3><h4 id="与成员函数有关的几个描述符："><a href="#与成员函数有关的几个描述符：" class="headerlink" title="与成员函数有关的几个描述符："></a>与成员函数有关的几个描述符：</h4><ol>
<li>成员函数前面使用const 表示返回值为const</li>
<li>成员函数后面加 const表示函数不可以修改class的成员</li>
<li>如果<strong>派生类</strong>在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数，否则代码将无法通过编译。</li>
<li>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错</li>
</ol>
<h4 id="重载与覆盖"><a href="#重载与覆盖" class="headerlink" title="重载与覆盖"></a>重载与覆盖</h4><p>​    覆盖是指派生类中如果存在重新定义的函数，其函数名、参数列、返回值类型必须同父类中的相对应被覆盖的函数严格一致。覆盖函数和被覆盖函数只有函数体不同，当派生类对象调用子类中该同名函数时会自动调用子类中的覆盖版本，而不是父类中的被覆盖函数版本。</p>
<h5 id="成员函数被重载的特征："><a href="#成员函数被重载的特征：" class="headerlink" title="成员函数被重载的特征："></a>成员函数被重载的特征：</h5><p>（1）相同的范围（在同一个类中）；</p>
<p>（2）函数名字相同（必须的，否则属于不同的函数了，更谈不上重载）；</p>
<p>（3）参数类型或个数，至少有一种不同（如果都相同的话，就是函数的重定义了；还要注意的是：如果函数参数相同，仅返回值不同的话，不是重载函数，编译时会报“有歧义”的错误）；</p>
<p>（4）virtual关键字可有可无（这个重载函数与虚函数一点关系没有，即使加上了也不是虚函数。如果在面试题中遇到了，纯粹是为了混淆你的思维，考察你对概念的理解）。</p>
<h5 id="覆盖是指派生类函数覆盖基类函数，特征是："><a href="#覆盖是指派生类函数覆盖基类函数，特征是：" class="headerlink" title="覆盖是指派生类函数覆盖基类函数，特征是："></a>覆盖是指派生类函数覆盖基类函数，特征是：</h5><p><strong>（1）不同的范围（分别位于派生类与基类）；</strong></p>
<p><strong>（2）函数名字相同；</strong></p>
<p><strong>（3）参数相同（这就属于重定义函数了）；</strong></p>
<p><strong>（4）基类函数必须有virtual关键字（这就是虚函数了）。</strong></p>
<h4 id="令人迷惑的隐藏规则"><a href="#令人迷惑的隐藏规则" class="headerlink" title="令人迷惑的隐藏规则"></a>令人迷惑的隐藏规则</h4><p>本来仅仅区别重载与覆盖并不算困难，但是C++的隐藏规则使问题复杂性陡然增加。这里“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下： </p>
<p><strong>（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。</strong></p>
<p><strong>（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆；如果基类函数有virtual关键字，就属于函数的覆盖了）。</strong></p>
<h4 id="关于虚函数与纯虚函数："><a href="#关于虚函数与纯虚函数：" class="headerlink" title="关于虚函数与纯虚函数："></a>关于虚函数与纯虚函数：</h4><p>定义一个函数为虚函数，不代表函数为不被实现的函数。</p>
<p>定义它为虚函数是为了允许用基类的指针来调用子类的这个函数。</p>
<p>定义一个函数为纯虚函数，才代表函数没有被实现。（这里好像有问题。。。）</p>
<p>定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</p>
<p>虚函数只能借助于指针或者引用来达到多态的效果</p>
]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>创建指定OpenCV版本的ROS工程</title>
    <url>/2020/12/19/chuang-jian-zhi-ding-opencv-ban-ben-ros-gong-cheng/</url>
    <content><![CDATA[<h1 id="创建指定OpenCV版本的ROS工程"><a href="#创建指定OpenCV版本的ROS工程" class="headerlink" title="创建指定OpenCV版本的ROS工程"></a>创建指定OpenCV版本的ROS工程</h1><h3 id="一、创建工作空间和程序包"><a href="#一、创建工作空间和程序包" class="headerlink" title="一、创建工作空间和程序包"></a>一、创建工作空间和程序包</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p ~/catkin_cv/src

<span class="token builtin class-name">cd</span> catkin_cv/

catkin_make

<span class="token builtin class-name">source</span> devel/setup.sh

<span class="token builtin class-name">cd</span> src

catkin_create_pkg ballseeker roscpp rospy std_msgs sensor_msgs cv_bridge image_transport dynamic_reconfigure<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="二、创建并且编写cpp文件与hpp文件"><a href="#二、创建并且编写cpp文件与hpp文件" class="headerlink" title="二、创建并且编写cpp文件与hpp文件"></a>二、创建并且编写cpp文件与hpp文件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gedit ballseeker/include/ballseeker/seek.hpp

gedit ballseeker/src/seek.cpp

gedit ballseeker/src/seekernode.cpp
<span class="token comment">#代码见附录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="三、修改CMakeLists-txt"><a href="#三、修改CMakeLists-txt" class="headerlink" title="三、修改CMakeLists.txt"></a>三、修改CMakeLists.txt</h3><p>​        在CMakeLists最后加上：</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment"># catkin_add_nosetests(test)</span>
<span class="token keyword">set</span><span class="token punctuation">(</span>OpenCV_DIR   /usr/local/share/OpenCV4<span class="token punctuation">)</span>
<span class="token keyword">find_package</span><span class="token punctuation">(</span>OpenCV REQUIRED<span class="token punctuation">)</span>

<span class="token keyword">add_library</span><span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span>  src/seek.cpp<span class="token punctuation">)</span>

<span class="token keyword">add_dependencies</span><span class="token punctuation">(</span>
   <span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span> 
   <span class="token punctuation">${</span><span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span>_EXPORTED_TARGETS<span class="token punctuation">}</span> 
   <span class="token punctuation">${</span>catkin_EXPORTED_TARGETS<span class="token punctuation">}</span>
<span class="token punctuation">)</span>

<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>
   <span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span>
   <span class="token punctuation">${</span>catkin_LIBRARIES<span class="token punctuation">}</span>
<span class="token punctuation">)</span>

<span class="token comment">#add the publisher example  </span>

<span class="token keyword">add_executable</span><span class="token punctuation">(</span>seekernode src/seek.cpp include/ballseeker/seek.hpp src/seekernode.cpp<span class="token punctuation">)</span>  
<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>seekernode <span class="token punctuation">${</span>catkin_LIBRARIES<span class="token punctuation">}</span> <span class="token punctuation">${</span>OpenCV_LIBRARIES<span class="token punctuation">}</span><span class="token punctuation">)</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="四、编译与运行"><a href="#四、编译与运行" class="headerlink" title="四、编译与运行"></a>四、编译与运行</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> catkin_cv/

<span class="token builtin class-name">source</span> ~/catkin_cv/devel/setup.sh

catkin_make
<span class="token comment">#新开一个终端运行：</span>
roscore
<span class="token comment">#再回之前的终端运行：</span>
rosrun ballseeker seekernode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="五、编写launch文件快速启动"><a href="#五、编写launch文件快速启动" class="headerlink" title="五、编写launch文件快速启动"></a>五、编写launch文件快速启动</h3><p>​        在终端中运行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/catkin_cv/src/ballseeker/launch

gedit quickstart.launch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        在quickstart.launch中写入：</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>launch</span><span class="token punctuation">&gt;</span></span>
    
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span>
		<span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>ballseeker<span class="token punctuation">"</span></span>
		<span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>quickseeknode<span class="token punctuation">"</span></span> 
		<span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>seekernode<span class="token punctuation">"</span></span>
	<span class="token punctuation">/&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>launch</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        回到终端再运行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/catkin_cv/devel/setup.sh

roslaunch ballseeker quickstart.launch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="六、dynamic-reconfigure"><a href="#六、dynamic-reconfigure" class="headerlink" title="六、dynamic_reconfigure"></a>六、dynamic_reconfigure</h3><p>​        略</p>
<h3 id="七、调整与保存参数"><a href="#七、调整与保存参数" class="headerlink" title="七、调整与保存参数"></a>七、调整与保存参数</h3><p>​        略</p>
<h3 id="八、附录（示例代码）"><a href="#八、附录（示例代码）" class="headerlink" title="八、附录（示例代码）"></a>八、附录（示例代码）</h3><blockquote>
<p>注意：这里的代码的作用是调用摄像头来检测它看到的网球</p>
</blockquote>
<p>​        在seek.hpp中写入：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#pragma once
#include "ros/ros.h"
#include "opencv2/opencv.hpp"
#include "vector"
#include "sstream"

const int red_ball = 0;
const int yellow_ball = 1;
const int blue_ball = 2;

class seek
{
public:
    seek(int service_id=0);
    ~seek();
    void getstart();        //从摄像头获取图片、双边滤波、转化hsv
    void display();         //找球并展示中间效果和最终效果
    void creatbar();        //创建滑动条调整参数

private:
    int bgr_min[3];
    int bgr_max[3];
    int hsv_min[3];
    int hsv_max[3];

    cv::Mat src;
    cv::Mat bgr_dst;
    cv::Mat hsv_dst;

    cv::Mat see_red;
    cv::Mat see_yellow;
    cv::Mat see_blue;

    cv::VideoCapture capture;
    void updateparam(int type_of_ball);
    void process(cv::Mat&amp; input,int type_of_ball);//阈值化、膨胀、找轮廓、找矩形并筛选、画圆
    static void on_change(int, void*);
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在seek.cpp中写入：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include "../include/ballseeker/seek.hpp"

seek::seek(int service_id)
{
    //设置摄像机参数
    capture.open(1);
    capture.set(CV_CAP_PROP_FRAME_WIDTH,640);
	capture.set(CV_CAP_PROP_FRAME_HEIGHT,480);
}

seek::~seek()
{

}

void seek::getstart()
{
    capture&gt;&gt;src;
    cv::bilateralFilter(src,bgr_dst,20,1000,1000);
    cv::cvtColor(bgr_dst,hsv_dst,CV_BGR2HSV);
}

void seek::display()
{
    process(see_red,red_ball);       //可能得会用bgr处理红球了，HSV下效果不太好
    process(see_yellow,yellow_ball);
    process(see_blue,blue_ball);
    cv::imshow("SEE_RED_BALL",see_red);
    cv::imshow("SEE_YELLOW_BALL",see_yellow);
    cv::imshow("SEE_BLUE_BALL",see_blue);

    cv::imshow("FINALLY",src);

    cv::waitKey(30);
}

void seek::process(cv::Mat&amp; input, int type_of_ball)
{
    updateparam(type_of_ball);

    cv::inRange(hsv_dst,cv::Scalar(hsv_min[0],hsv_min[1],hsv_min[2]),
        cv::Scalar(hsv_max[0],hsv_max[1],hsv_max[2]),input);

    cv::Mat element =cv::getStructuringElement(cv::MORPH_RECT, cv::Size(15, 15));   
    cv::dilate(input, input, element);

    std::vector&lt;std::vector&lt;cv::Point&gt; &gt; contours;
    std::vector&lt;cv::Vec4i&gt; hierarchy;
    std::vector&lt;cv::Rect&gt; rects;

    cv::findContours(input, contours, hierarchy, cv::RETR_CCOMP, cv::CHAIN_APPROX_SIMPLE);

    for (int i = 0; i &lt; contours.size(); i++)
    {
        rects.push_back(cv::boundingRect(contours[i]));
        if ((rects.back().height &lt; 100 || rects.back().width &lt; 100) ||
            fabsf(rects.back().height - rects.back().width) &gt; 20)
            rects.erase(rects.end() - 1);
    }

    for (int i = 0; i &lt; rects.size(); i++)
    {
        double R = (rects[i].height + rects[i].width) / 4;
        double x = rects[i].x + R;
        double y = rects[i].y + R;
        cv::Point center(x, y);
        cv::circle(src, center, R + 5, cv::Scalar(0, 0, 255), 5);
    }
}

void seek::updateparam(int type_of_ball)
{
    switch (type_of_ball)
    {
    case red_ball:
        hsv_min[0]= 0 ;hsv_min[1]= 105 ;hsv_min[2]= 108 ;
        hsv_max[0]= 11 ;hsv_max[1]= 255 ;hsv_max[1]= 255 ;
        break;
    case yellow_ball:
        hsv_min[0]= 18 ;hsv_min[1]= 56 ;hsv_min[2]= 177 ;
        hsv_max[0]= 71 ;hsv_max[1]= 187 ;hsv_max[1]= 255 ;
        break;
    case blue_ball:
        hsv_min[0]= 85 ;hsv_min[1]= 129 ;hsv_min[2]= 128 ;
        hsv_max[0]= 124 ;hsv_max[1]= 255 ;hsv_max[1]= 255 ;
        break;
    default:
        break;
    }
}

void seek::creatbar()
{
    cv::namedWindow("SetParam");
	cv::createTrackbar("minH", "SetParam", &amp;hsv_min[0], 180, on_change);
	cv::createTrackbar("minS", "SetParam", &amp;hsv_min[1], 255, on_change);
	cv::createTrackbar("minV", "SetParam", &amp;hsv_min[2], 255, on_change);
	cv::createTrackbar("maxH", "SetParam", &amp;hsv_max[0], 180, on_change);
	cv::createTrackbar("maxS", "SetParam", &amp;hsv_max[1], 255, on_change);
	cv::createTrackbar("maxV", "SetParam", &amp;hsv_max[2], 255, on_change);
	on_change(0, 0);
}

void seek::on_change(int, void*)
{

}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在seekernode.cpp中写入：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include "../include/ballseeker/seek.hpp"


int main(int argc,char** argv)
{
    ros::init(argc,argv,"seekernode");
    ros::NodeHandle n;

    seek icu(1);
    icu.creatbar();

    while(ros::ok())
    {
        icu.getstart();
        icu.display();
        ros::spinOnce();
    }

    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>我的留学计划</title>
    <url>/2021/02/25/wo-de-liu-xue-ji-hua/</url>
    <content><![CDATA[<h2 id="我的留学计划"><a href="#我的留学计划" class="headerlink" title="我的留学计划"></a>我的留学计划</h2><blockquote>
<p>无奈生了一颗爱闯荡的心，对外面的世界念念不忘。</p>
</blockquote>
<h2 id="留学目的"><a href="#留学目的" class="headerlink" title="留学目的"></a>留学目的</h2><p>我觉得，我留学的目的是积极的。我不是因为厌倦了当前的生活，想逃避保研或者考研而选择出国留学；我也清楚海的那边，一样很残酷，在一个对自己的血统没有歧视的国度里，在一个竞争并不算激烈、甚至生活上还称得上有保障的社会中，在一个对自己来说没有任何语言、文化障碍的环境下，自己都算不上一个成功者的话，我有什么资本可以奢望在出国后，自己能够摇身一变，以胜者的姿态生存下来？我又有什么理由不继续失败？我怎么就那么自信地说因为我在国内做不好，所以我出国就能做好？成功的人在不同的地方有不同的成功方式，但是失败的人在不同的地方会有完全相同的失败方法。</p>
<p>目前的我，对未来最美好的憧憬就是：能够在高水平的高校里任职，无论是国内还是国外。同时，我也对机器人技术充满好奇与期待，对计算机视觉充满热情，真心的想从事这方面的学术研究工作。</p>
<p>所以，我出国留学，一个是想学习更多的知识，获得更广阔的视野；另一个是在国外更高更好的平台上，尽可能的做出成果，为以后进入高校任职做准备。</p>
<h2 id="目前情况"><a href="#目前情况" class="headerlink" title="目前情况"></a>目前情况</h2><p>西北工业大学软件学院19级本科生</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td>GPA</td>
<td>3.71，比较低，没有优势</td>
</tr>
<tr>
<td>RANK</td>
<td>专业10%左右，没有优势</td>
</tr>
<tr>
<td>研究方向</td>
<td>CV（主要是SLAM）</td>
</tr>
<tr>
<td>研究经历</td>
<td>足球基地人基地V5++团队成员；中国机器人大赛无人机挑战赛无人机快递项目亚军</td>
</tr>
<tr>
<td>目标高校</td>
<td>卡耐基梅隆大学机器人学院、香港科技大学空中机器人实验室、苏黎世联邦理工大学计算机视觉与几何实验室、慕尼黑工业大学计算机视觉组、香港中文大学天石机器人实验室</td>
</tr>
</tbody></table>
<h2 id="未来规划"><a href="#未来规划" class="headerlink" title="未来规划"></a>未来规划</h2><blockquote>
<p>需要不间断的调整和完善！</p>
</blockquote>
<h3 id="大二下学期"><a href="#大二下学期" class="headerlink" title="大二下学期"></a>大二下学期</h3><ul>
<li><p>尽快的寻找本科生导师，目前比较想找下面这位导师。</p>
<p>主要是想依靠导师来指导本科阶段的学习，尽早的为以后的研究生阶段做准备，并且争取做好校研、论文发表，快速提升自己的能力并找到比较好的暑研。</p>
<p><img src="/images/MyPlan/npubsh.png"></p>
</li>
<li><p>刷高GPA，要求3.80以上</p>
</li>
<li><p>学习英语，备考六级，最低要求580+</p>
</li>
<li><p>真正的确定自己未来的研究方向、申请的专业方向</p>
</li>
<li><p>待定</p>
</li>
</ul>
<h3 id="大二暑假"><a href="#大二暑假" class="headerlink" title="大二暑假"></a>大二暑假</h3><ul>
<li>科研、暑研</li>
<li>准备GRE和托福</li>
<li>学习和提升自己的专业水平和英语水平，提前适应国外的教学模式</li>
<li>待定</li>
</ul>
<h3 id="大三上学期"><a href="#大三上学期" class="headerlink" title="大三上学期"></a>大三上学期</h3><p>待定</p>
<h3 id="大三下学期"><a href="#大三下学期" class="headerlink" title="大三下学期"></a>大三下学期</h3><p>待定</p>
<h3 id="大三暑假"><a href="#大三暑假" class="headerlink" title="大三暑假"></a>大三暑假</h3><p>待定</p>
<h3 id="大四上学期"><a href="#大四上学期" class="headerlink" title="大四上学期"></a>大四上学期</h3><p>待定</p>
<h3 id="大四下学期"><a href="#大四下学期" class="headerlink" title="大四下学期"></a>大四下学期</h3><p>待定</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><img src="/images/MyPlan/timeline.jpg"></p>
]]></content>
      <categories>
        <category>经验&amp;方法</category>
      </categories>
      <tags>
        <tag>出国留学</tag>
      </tags>
  </entry>
  <entry>
    <title>理解SVM的三层境界</title>
    <url>/2021/02/23/li-jie-svm-de-san-ceng-jing-jie/</url>
    <content><![CDATA[<h1 id="理解SVM的三层境界"><a href="#理解SVM的三层境界" class="headerlink" title="理解SVM的三层境界"></a>理解SVM的三层境界</h1><p>SVM是什么? 先来看看维基百科上对<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA">SVM的定义</a>:</p>
<blockquote>
<p>支持向量机（英语：support vector machine，常简称为SVM，又名支持向量网络）是在分类与回归分析中分析数据的监督式学习模型与相关的学习算法。给定一组训练实例，每个训练实例被标记为属于两个类别中的一个或另一个，SVM训练算法创建一个将新的实例分配给两个类别之一的模型，使其成为非概率二元线性分类器。SVM模型是将实例表示为空间中的点，这样映射就使得单独类别的实例被尽可能宽的明显的间隔分开。然后，将新的实例映射到同一空间，并基于它们落在间隔的哪一侧来预测所属类别。</p>
</blockquote>
<p>如果从未接触SVM的话，维基的这一大段解释肯定会让你一头雾水。简单点讲，SVM就是一种二类分类模型，他的基本模型是的定义在特征空间上的<strong>间隔最大</strong>的线性分类器，SVM的学习策略就是间隔最大化。</p>
<p>下面是我从网上找到的一篇讲解SVM比较好的文章：</p>
<object data="/pdf/理解SVM的三层境界.pdf" type="application/pdf" width="100%" height="1000">

</object>]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>类的六个默认的成员函数</title>
    <url>/2020/08/21/lei-de-liu-ge-mo-ren-de-cheng-yuan-han-shu/</url>
    <content><![CDATA[<h1 id="类的六个默认的成员函数"><a href="#类的六个默认的成员函数" class="headerlink" title="类的六个默认的成员函数"></a>类的六个默认的成员函数</h1><h2 id="类的6个默认的成员函数包括："><a href="#类的6个默认的成员函数包括：" class="headerlink" title="类的6个默认的成员函数包括："></a>类的6个默认的成员函数包括：</h2><p>构造函数、析构函数、拷贝构造函数、赋值运算符重载函数、取地址操作符重载、const修饰的取地址操作符重载。</p>
<h3 id="（一）构造函数"><a href="#（一）构造函数" class="headerlink" title="（一）构造函数"></a>（一）构造函数</h3><p>构造函数，顾名思义，为对象分配空间，进行初始化。它是一种特殊的成员函数，具有以下特点:</p>
<ol>
<li><p>函数名与类名相同。</p>
</li>
<li><p>无返回值。</p>
</li>
<li><p>构造对象的时候系统会自动调用构造函数。</p>
</li>
<li><p>可以重载。</p>
</li>
<li><p>可以在类中定义，也可以在类外定义。</p>
</li>
<li><p>如果类中没有给出构造函数，编译器会自动产生一个缺省的构造函数，如果类中有构造函数，编译器就不会产生缺省构造函数。</p>
</li>
<li><p>全缺省的构造函数和无参的构造函数只能有一个，否则调用的时候就会产生冲突。</p>
</li>
<li><p>没有this指针。因为构造函数才是创建对象的，没有创建对象就不会有对象的首地址。</p>
</li>
</ol>
<p>构造函数，说来就是给成员变量进行初始化。而初始化却有两种方法：初始化列表、构造函数函数体内赋值。尽量使用初始化列表，因为它更高效。</p>
<h4 id="有些成员变量必须再初始化列表中初始化，比如："><a href="#有些成员变量必须再初始化列表中初始化，比如：" class="headerlink" title="有些成员变量必须再初始化列表中初始化，比如："></a>有些成员变量必须再初始化列表中初始化，比如：</h4><ol>
<li><p>常量成员变量。（常量创建时必须初始化，因为对于一个常量，我们给它赋值，是不对的）</p>
</li>
<li><p>引用类型成员变量。（引用创建时必须初始化）</p>
</li>
<li><p>没有缺省构造函数的类成员变量。（如果构造函数的参数列表中有一个类的对象，并且该对象的类里没有缺省参数的构造函数时，要是不使用初始化列表，参数中会调用无参或者全缺省的构造函数，而那个类中又没有。）</p>
</li>
</ol>
<h3 id="（二）析构函数"><a href="#（二）析构函数" class="headerlink" title="（二）析构函数"></a>（二）析构函数</h3><h4 id="析构函数是一种特殊的成员函数，具有以下特点："><a href="#析构函数是一种特殊的成员函数，具有以下特点：" class="headerlink" title="析构函数是一种特殊的成员函数，具有以下特点："></a>析构函数是一种特殊的成员函数，具有以下特点：</h4><ol>
<li><p>析构函数函数名是在类名加上字符 ~ 。</p>
</li>
<li><p>无参数无返回值（但有this指针）。</p>
</li>
<li><p>一个类有且只有一个析构函数，所以肯定不能重载。若未显示定义，系统会自动生成缺省的析构函数。</p>
</li>
<li><p>对象生命周期结束时，C++编译系统系统自动调用析构函数。</p>
</li>
<li><p>注意析构函数体内并不是删除对象，而是做一些清理工作。（比如我们在构造函数中动态开辟过一段空间，函数结束后需要释放，而系统自动生成的析构函数才不管内存释放呢，所以需要人为地写出析构函数）</p>
</li>
</ol>
<p>注意：对象生命周期结束后，后构造的对象先释放。</p>
<h3 id="（三）拷贝构造函数"><a href="#（三）拷贝构造函数" class="headerlink" title="（三）拷贝构造函数"></a>（三）拷贝构造函数</h3><p>用已有的对象创建一个新的对象。</p>
<p>创建对象时使用同类对象来进行初始化，这时所用的构造函数就是拷贝构造函数（Copy  Constructor）。拷贝构造函数也是构造函数，但它只有一个参数，这个参数只能是本类的一个对象，而且采用对象的常引用形式。拷贝构造函数的作用就是将实参对象的各成员值一一赋给新的对象中对应的成员。</p>
<p>该函数的参数是一个常引用，如果不是引用，形参是实参的一份临时拷贝，由于两者都是对象，此时就会调用自己的拷贝构造函数，陷入无限递归中…….</p>
<h4 id="拷贝构造函数的特征"><a href="#拷贝构造函数的特征" class="headerlink" title="拷贝构造函数的特征"></a>拷贝构造函数的特征</h4><p> （1）拷贝构造函数其实是一个构造函数的重载。<br> （2）拷贝构造函数的参数必须使用引用传参，使用传参方式会引发无穷递归调用。<br> （3）若为显示定义，系统默认生成缺省的拷贝构造函数，缺省的拷贝构造函数会按照成员的声明顺序依次拷贝类成员进行初始化</p>
<h4 id="调用拷贝构造函数的两种方法："><a href="#调用拷贝构造函数的两种方法：" class="headerlink" title="调用拷贝构造函数的两种方法："></a>调用拷贝构造函数的两种方法：</h4><ol>
<li><p>代入法：</p>
<p>Person p2(p1);</p>
</li>
<li><p>赋值法：</p>
<p>Person p2 = p1;</p>
</li>
</ol>
<h4 id="为什么这里的对象可以直接访问私有成员变量？"><a href="#为什么这里的对象可以直接访问私有成员变量？" class="headerlink" title="为什么这里的对象可以直接访问私有成员变量？"></a>为什么这里的对象可以直接访问私有成员变量？</h4><p> 1）在类的成员函数里可以直接访问同类对象的私有或保护的成员。<br> 2）C++的访问限定符是以类为单位的，即：在这个单位内的成员可以互相访问。</p>
<h3 id="（四）赋值运算符重载函数"><a href="#（四）赋值运算符重载函数" class="headerlink" title="（四）赋值运算符重载函数"></a>（四）赋值运算符重载函数</h3><p>用一个对象修改已经存在对象的内容，不是去创建新的对象，修改之后，两个对象的内容一致</p>
<blockquote>
<ol>
<li>可以通过检查是否给自己赋值，进行优化</li>
<li><strong>如果需要连续赋值，返回值不能是void，一般为引用类型</strong></li>
<li>*<em>返回值一般是 <em>this</em></em></li>
<li>编译器默认生成的赋值运算符为字节拷贝，即浅拷贝，如果资源需要拷贝，需要显示定义，完成深拷贝</li>
</ol>
<p>=调用：如果对象都存在，调用赋值运算符重载函数</p>
<p>​              如果左边对象不存在，调用拷贝构造创建左边对象</p>
</blockquote>
<p><em>赋值是从右向左进行的</em></p>
<p>如果不写，编译器会自动生成，默认生成的也是字节拷贝，浅拷贝</p>
<p>如果当前类中有资源，则必须显示定义运算符重载函数，完成深拷贝</p>
<h4 id="普通运算符重载函数"><a href="#普通运算符重载函数" class="headerlink" title="普通运算符重载函数"></a>普通运算符重载函数</h4><blockquote>
<ol>
<li>不能创建新的操作符，如operator@</li>
<li>重载操作符必须有一个类类型或者枚举类型的操作符</li>
<li>用于内置类型的操作符，其含义不能改变</li>
<li>运算符重载函数如果是成员函数，则参数的个数比运算符需要的个数少一个，这里编译器会传入this指针作为第一个参数</li>
<li>普通的运算符重载函数，参数的个数和运算符需要的个数一致</li>
</ol>
</blockquote>
<p><strong>.*（成员指针访问运算符） ,  ::  ,  sizeof  ,  ? :  ,  .   五个运算符不能被重载</strong></p>
<h3 id="（五）取地址运算符重载函数-const取地址运算符重载函数：获取对象的地址"><a href="#（五）取地址运算符重载函数-const取地址运算符重载函数：获取对象的地址" class="headerlink" title="（五）取地址运算符重载函数 / const取地址运算符重载函数：获取对象的地址**"></a>（五）取地址运算符重载函数 / const取地址运算符重载函数：获取对象的地址**</h3><p>一般不需要显示定义，直接使用编译器自动生成的即可</p>
]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉SLAM十四讲笔记</title>
    <url>/2021/01/27/shi-jue-slam-shi-si-jiang-bi-ji/</url>
    <content><![CDATA[<h1 id="《视觉SLAM十四讲》笔记"><a href="#《视觉SLAM十四讲》笔记" class="headerlink" title="《视觉SLAM十四讲》笔记"></a>《视觉SLAM十四讲》笔记</h1><h2 id="第一、二讲-初识SLAM"><a href="#第一、二讲-初识SLAM" class="headerlink" title="第一、二讲    初识SLAM"></a>第一、二讲    <code>初识SLAM</code></h2><h3 id="一、知识总结"><a href="#一、知识总结" class="headerlink" title="一、知识总结"></a>一、知识总结</h3><ol>
<li><p>slam英文为Simultaneous Localization and Mapping，意思是同时定位与建图。它指搭建特定的传感器的主体，在没有环境先验信息的情况下，在运动过程中建立环境的模型，同时估计自己的运动。当传感器主要为相机时，可称为‘视觉slam’。</p>
</li>
<li><p>slam技术应用在机器人定位导航，AR/VR、三feixianxingyouhua维重建等领域。</p>
</li>
<li><p>slam框架主要包括传感器信息读取、视觉里程计、后端优化、建图以及回环检测五部分。</p>
<p><img src="/images/slam-notes/1.png"></p>
<ul>
<li>传感器信息的读取：主要为图像信息的读取和预处理。以及其他传感器如惯性传感器信息的读取和处理</li>
<li>视觉里程计：估计相邻图像间的运动。单独的vo存在累计漂移问题。</li>
<li>后端优化：对相机位姿和回环检测的信息进行优化，采用滤波和非线性优化方法，解决在带有噪声的数据中，估计整个系统的状态，以及状态估计的不确定性。目的是得到全局一致的轨迹和地图。</li>
<li>建图：目的是解决位置估计随时间漂移的问题，建立与任务对应的地图。需要使机器人识别曾经到达过的场景的能力。如判断图像间相似性来完成回环检测。分为度量地图和拓扑地图。</li>
</ul>
</li>
<li><p>拓扑地图：强调地图元素的关系，由节点和边组成，只考虑节点的联通性。</p>
</li>
<li><p>度量地图：强调精确地表示地图中物体的位置关系，用稀疏和稠密对它们进行分类。二维度量地图是许多个小格子组成，三维是方块。包括占据、空闲以及未知三种状态。</p>
</li>
</ol>
<h3 id="二、数学表述"><a href="#二、数学表述" class="headerlink" title="二、数学表述"></a>二、数学表述</h3><ol>
<li>运动方程</li>
</ol>
<p><img src="/images/slam-notes/2.png"></p>
<ol start="2">
<li><p>观测方程</p>
<p><img src="/images/slam-notes/3.png"></p>
</li>
<li><p>符号意义x为机器人各时刻位置,y为路标，u为传感器的输入数据，w、v为噪声。z为观测数据。机器人在环境中移动可以描述为运动方程和观测方程，转化为求解定位x和建图y的问题。问题建模为一个状态估计问题。</p>
</li>
</ol>
<h2 id="第三讲-三维空间刚体运动"><a href="#第三讲-三维空间刚体运动" class="headerlink" title="第三讲    三维空间刚体运动"></a>第三讲    <code>三维空间刚体运动</code></h2><ol>
<li><p>内积：描述向量间的投影关系<br><img src="/images/slam-notes/4.png"></p>
</li>
<li><p>外积：外积的方向垂直a、b两个向量，大小为|a||b|sin&lt;a, b&gt;</p>
</li>
<li><p>它是两个向量张成的四边形的有向面积。外积只对三维向量存在定义，可以表示旋转^表示反对称符号，外积公式：<br><img src="/images/slam-notes/5.png"></p>
</li>
<li><p>欧氏变换：同一个向量在各个坐标系下的长度和夹角都不会发生变换，称为欧氏变换。</p>
</li>
<li><p>旋转矩阵：描述了旋转本身。它是行列式为1的正交矩阵。SO表示特殊正交群，集合定义如下：<br><img src="/images/slam-notes/6.png"></p>
</li>
<li><p>世界坐标系下向量a经过旋转R和平移t到a’描述一个欧氏空间完的变换关系。<br><img src="/images/slam-notes/7.png"></p>
</li>
<li><p>变换矩阵和齐次坐标是使用数学技巧，把转换关系变为线性关系。变换矩阵为特殊欧氏群，表示为：</p>
<p><img src="/images/slam-notes/8.png"></p>
</li>
<li><p>欧拉角：把一个旋转分解成三次绕不同轴的旋转。使用前要定义方向，如：偏航-俯仰-滚转等价于ZYX旋转。</p>
<p>欧拉角的一个重大缺点是会碰到著名的万向锁问题（Gimbal Lock）：在俯仰角为 ±90◦ 时，第一次旋转与第三次旋转将使用同一个轴，使得系统丢失了一个自由度（由三次 旋转变成了两次旋转）。这被称为奇异性问题，在其他形式的欧拉角中也同样存在。</p>
<p><img src="/images/slam-notes/9.png"></p>
<p>俯仰角在±90°时欧拉角出现万向锁的过程：</p>
<p>​    假设旋转顺序是 xyz，    </p>
<p>​    第一次绕x轴旋转，得到 xy’z’</p>
<p>​    第二次绕y’轴旋转90度，得到 x’y’z’’</p>
<p>​    由于y’旋转了90度，导致z’’与 x同轴了，这样在z’’上的旋转等价于最初在x上的旋转。</p>
<p>​    相当于这一次的 xyz操作，可以简化为 xy. 我们将这个现象称为 万向锁。</p>
</li>
<li><p>旋转向量：使用方向与旋转轴n一致，长度等于旋转角的向量θ称为旋转向量，相比旋转矩阵更加紧凑，维数为6维。旋转矩阵和旋转向量之间的公式叫罗德里格斯，转换公式如下：<br><img src="/images/slam-notes/10.png"></p>
<blockquote>
<p> 符号 ∧ 是向量到反对称的转换符</p>
</blockquote>
</li>
<li><p>四元数q:用复数的乘法表示旋转，紧凑的，没有奇异性。性质：一个模长为1的复数，可表示复平面的纯旋转；任意的旋转都可以用互为相反数的四元数表示；满足一定的运算。<br>  公式表达如下：<br>  <img src="/images/slam-notes/11.png"></p>
<p>其中 i, j, k 为四元数的三个虚部。这三个虚部满足关系式：</p>
<p><img src="/images/slam-notes/12.png"></p>
</li>
<li><p>用四元数表示旋转：</p>
<p><img src="/images/slam-notes/a.png"></p>
</li>
<li><p>各种描述之间的转换</p>
<p><img src="/images/slam-notes/b.png"></p>
</li>
</ol>
<h2 id="第四讲-李群与李代数"><a href="#第四讲-李群与李代数" class="headerlink" title="第四讲    李群与李代数"></a>第四讲    <code>李群与李代数</code></h2><h3 id="一、李群"><a href="#一、李群" class="headerlink" title="一、李群"></a>一、李群</h3><p>群（Group）是一种集合加上一种运算的代数结构。我们把集合记作 A，运算记作 ·， 那么群可以记作 G = (A, ·)。群要求这个运算满足以下几个条件：</p>
<p><img src="/images/slam-notes/15.png"></p>
<p>矩阵中常见的群有：</p>
<p>一般线性群 GL(n) 指 n × n 的可逆矩阵，它们对矩阵乘法成群。</p>
<p>特殊正交群 SO(n) 也就是所谓的旋转矩阵群，其中 SO(2) 和 SO(3) 最为常见。</p>
<p>特殊欧氏群 SE(n) 也就是前面提到的 n 维欧氏变换，如 SE(2) 和 SE(3)。</p>
<p><strong>李群</strong>是指具有连续（光滑）性质的群。像整数群 Z 那样离散的群没有连续性质，所以不是李群。而 SO(n) 和 SE(n)，它们在实数空间上是连续的。我们能够直观地想象一个刚体能够连续地在空间中运动，所以它们都是李群。</p>
<p><img src="/images/slam-notes/16.png"></p>
<h3 id="二、李代数"><a href="#二、李代数" class="headerlink" title="二、李代数"></a>二、李代数</h3><p>每个李群都有与之对应的李代数。李代数描述了李群的局部性质。通用的李代数的定义如下：</p>
<p>李代数由一个集合 V，一个数域 F 和一个二元运算 [, ] 组成。如果它们满足以下几条 性质，称 (V, F, [, ]) 为一个李代数，记作 g。</p>
<p><img src="/images/slam-notes/17.png"></p>
<p>其中二元运算被称为李括号。</p>
<h4 id="2-1-李群SO-3-的李代数so-3"><a href="#2-1-李群SO-3-的李代数so-3" class="headerlink" title="2.1 李群SO(3)的李代数so(3)"></a>2.1 李群SO(3)的李代数so(3)</h4><p><img src="/images/slam-notes/c.png"></p>
<h4 id="2-2-李群SE-3-的李代数se-3"><a href="#2-2-李群SE-3-的李代数se-3" class="headerlink" title="2.2 李群SE(3)的李代数se(3)"></a>2.2 李群SE(3)的李代数se(3)</h4><p><img src="/images/slam-notes/d.png"></p>
<h3 id="三、指数与对数映射"><a href="#三、指数与对数映射" class="headerlink" title="三、指数与对数映射"></a>三、指数与对数映射</h3><p>指数映射反映了从李代数到李群的对应关系：<code>R=exp(ϕ^)</code></p>
<p>由于 <code>ϕ</code> 是向量，定义其角度和模长：</p>
<p>​    角度乘单位向量：<code>ϕ=θa</code></p>
<p>​    关于 <code>a</code> ，可以验证以下性质：</p>
<p><img src="/images/slam-notes/19.png">    </p>
<p>​    <img src="/images/slam-notes/20.png"></p>
<p>Taylor展开：</p>
<p><img src="/images/slam-notes/21.png"></p>
<p>结果：（对比之前的罗德里格斯公式）</p>
<p><img src="/images/slam-notes/22.png"></p>
<p><strong>SO(3)上的指数映射</strong></p>
<p><img src="/images/slam-notes/23.png"></p>
<p><strong>SE(3)上的指数映射</strong></p>
<p><img src="/images/slam-notes/24.png"></p>
<p><img src="/images/slam-notes/25.png"></p>
<p><strong>SO(3), SE(3), so(3), se(3) 的对应关系</strong></p>
<p><img src="/images/slam-notes/26.png"></p>
<h2 id="第五讲-相机与图像"><a href="#第五讲-相机与图像" class="headerlink" title="第五讲    相机与图像"></a>第五讲    <code>相机与图像</code></h2><h3 id="一、相机"><a href="#一、相机" class="headerlink" title="一、相机"></a>一、相机</h3><p>相机主要分为单目（Monocular）、双目(Stereo)、深度相机(RGB-D)三类。</p>
<ol>
<li>单目相机：是三维空间的二维投影，可以用来估计相机运动和结构（场景的大小和远近）。<br>原理是近处的物体移动的快、远处的物体移动慢，相机运动可以形成视差。<br>优点：成本低；<br>缺点：尺度不确定性，无法估计物体的真实尺度。例如相机的运动和场景同时放大两倍，单目所看到的像是一样的。</li>
<li>双目相机：基线（两个相机间的距离）来估计每个像素的空间位置。基线越大，测量的物体越远。<br>优点：解决了尺度不确定性。<br>缺点：深度量程和精度受双目的基线和分辨率限制；视差的计算消耗计算资源。</li>
<li>深度相机：通过红外结构光或Time-of-Fligfeixianxingyouhuaht(ToF)原理，用物理方法测量物体的距离。<br>优点：相比双目节省计算量。<br>缺点：测量范围窄、噪声大、视野小、易受日光干扰、无法测量透射材料等</li>
</ol>
<h3 id="二、坐标系"><a href="#二、坐标系" class="headerlink" title="二、坐标系"></a>二、坐标系</h3><ul>
<li><p>世界坐标</p>
<ul>
<li>也就是真实世界的立体空间坐标，是一个三维坐标系</li>
<li><em>Ow-XwYwZw</em>：世界坐标系,描述相机位置,单位m</li>
</ul>
</li>
<li><p>相机坐标</p>
<ul>
<li>根据透镜成像原理，将世界坐标在照相机内呈现，是一个三维坐标系</li>
<li><em>Oc-XcYcZc</em>：相机坐标系,光心为原点,单位m</li>
</ul>
</li>
<li><p>图像坐标</p>
<ul>
<li><p>将相机呈现的三维坐标投影到屏幕上，而建立的新坐标系，不含距离信息，是一个二维坐标系</p>
</li>
<li><p><em>o-xy</em> ：图像坐标系,原点为成像平面中点,单位mm一、相机<br>相机主要分为单目（Monocular）、双目(Stereo)、深度相机(RGB-D)三类。</p>
<p>单目相机：是三维空间的二维投影，可以用来估计相机运动和结构（场景的大小和远近）。<br>原理是近处的物体移动的快、远处的物体移动慢，相机运动可以形成视差。<br>优点：成本低；<br>缺点：尺度不确定性，无法估计物体的真实尺度。例如相机的运动和场景同时放大两倍，单目所看到的像是一样的。</p>
<p>双目相机：基线（两个相机间的距离）来估计每个像素的空间位置。基线越大，测量的物体越远。<br>优点：解决了尺度不确定性。<br>缺点：深度量程和精度受双目的基线和分辨率限制；视差的计算消耗计算资源。</p>
<p>深度相机：通过红外结构光或Time-of-Fligfeixianxingyouhuaht(ToF)原理，用物理方法测量物体的距离。<br>优点：相比双目节省计算量。<br>缺点：测量范围窄、噪声大、视野小、易受日光干扰、无法测量透射材料等</p>
</li>
</ul>
</li>
<li><p>像素坐标</p>
<ul>
<li>将投影的图像坐标离散抽样形成的做种图片，是一个二维的坐标系</li>
<li><em>uv</em> ：像素坐标系,原点为图像左上角,单位pixel</li>
</ul>
<p><img src="/images/slam-notes/27.png"></p>
</li>
</ul>
<h3 id="三、针孔相机模型"><a href="#三、针孔相机模型" class="headerlink" title="三、针孔相机模型"></a>三、针孔相机模型</h3><p><img src="/images/slam-notes/28.png"></p>
<p><strong>针孔相机模型的矩阵形式：</strong></p>
<p>中间的矩阵是相机的内参，记为K。</p>
<p><img src="/images/slam-notes/29.png"></p>
<p>除内参外，相机坐标系P与世界坐标系Pw还相差一个变换：</p>
<p><img src="/images/slam-notes/30.png"></p>
<p>这里 R, t 或 T 称为外参，是SLAM估计的目标。</p>
<h3 id="四、畸变"><a href="#四、畸变" class="headerlink" title="四、畸变"></a>四、畸变</h3><p>相机的前方通常会有一个透镜，会对成像产生影响，称为畸变。</p>
<p>由透镜形状引起的畸变称为径向畸变，包括桶形畸变和枕形畸变。桶形畸变是由于图像放大率随着与光轴之间的距离增加而减小；枕形畸变相反。</p>
<p><img src="/images/slam-notes/31.png"></p>
<p>径向畸变的程度会随着与中心距离的增加而增加，可以通过公式(5.11)进行矫正。 </p>
<p><img src="/images/slam-notes/32.png"></p>
<p>透镜在装机过程中不和成像平面严格平行会引入切向畸变。</p>
<p><img src="/images/slam-notes/33.png"></p>
<p>切向畸变通过公式(5.12)矫正。</p>
<p><img src="/images/slam-notes/34.png"></p>
<p>对于畸变的矫正在实际当中可灵活保留各项系数。通常在视觉SLAM中，考虑先对整张图片进行去畸变，得到去畸变后的图像，然后讨论图像中的点的位置。</p>
<h2 id="第六讲-非线性优化"><a href="#第六讲-非线性优化" class="headerlink" title="第六讲    非线性优化"></a>第六讲    <code>非线性优化</code></h2><p>待更新~</p>
]]></content>
      <categories>
        <category>视觉SLAM</category>
      </categories>
      <tags>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>出国留学经验整理</title>
    <url>/2021/02/24/chu-guo-liu-xue-jing-yan-zheng-li/</url>
    <content><![CDATA[<h1 id="出国留学经验整理"><a href="#出国留学经验整理" class="headerlink" title="出国留学经验整理"></a>出国留学经验整理</h1><h2 id="上交生存手册"><a href="#上交生存手册" class="headerlink" title="上交生存手册"></a>上交生存手册</h2><h3 id="学习方式"><a href="#学习方式" class="headerlink" title="学习方式"></a>学习方式</h3><p>学习最需要的，不是悲壮的毅力，而是对无限未知的渴求。</p>
<p>最终来说，<strong>学习知识的目的是为后继的知识铺垫，以及培养创造性的思维。所谓有效率的学习，应当是以最高的效率获取知识，服务这两个目标。</strong>从现状来看，我们<strong>想要把什么都搞扎实的学习习惯，其效率是极端低下的</strong>，而在我们通过大量习题，最终扎实掌握的信息里，有效的“知识”却又是如此的少。</p>
<h3 id="正确地浪费剩下的时间"><a href="#正确地浪费剩下的时间" class="headerlink" title="正确地浪费剩下的时间"></a>正确地浪费剩下的时间</h3><p>相比宝贵的青春，我们在上学期间所需要的学费和生活开销几乎可以忽略不计。<strong>我们真正投下的有价值的筹码，是时间。</strong>面对着足以改变你人生轨迹的黄金时间，你是否感到了它的沉重？你又是否想过要如何计划这笔巨额投资？</p>
<p><strong>无论你做的事情是否有意义——哪怕任何事情都不做，时间也会从我们的身边溜走。我们必须一日三省问自己，今天的时间是否过得有价值。</strong></p>
<p><strong>一般来说，一项任务的价值，取决于它在时间尺度上的作用效率。</strong>花同样的功夫，我们应该尽量多做那些对整个人生都产生正面影响的事情，少做对中期的未来产生影响的事情，不做那些只对近期产生影响的事情。当然，产生负面影响的事是最应该避免的。从这个意义上说，花适当的时间锻炼身体能让我们终身受益，值得做；但是即便只花同样时间，我们也不应该打游戏，因为那只能获得转瞬即逝的空虚的精神愉悦。</p>
<p>安排时间道理真的很浅显：成功人士往往会津津乐道于他们在校期间锻炼出的专业素养，但几乎没有成熟（甚至不需要成功）的人，喜欢炫耀自己当年高数考了年级第一。</p>
<p>在另外一些时候，我们会给“上课”找一个更加堂而皇之的理由：学习知识。关于大学课堂的教学质量以及课堂所关注的所谓“解题技巧”，我已经不想再作赘述。简而言之，上课中，我们获得有用知识的效率是如此之低，以至于任何一种有效的自习方式都会轻松地获得更大的回报。打比方说，一个学期的英语课，每周四节共计48小时。在课堂上，我们有一半时间要忍受台上同学支离破碎的英语。然而，花同样的时间，一个智力正常的同学完全可以熟练背诵2000个单词（这个数字是根据广大GRE考生的备考状况进行的保守估测）。这2000单词足够让你的英语水平整体上一个台阶。敢问，一个学期的英语课，你又能学到什么呢？最多不过是熟练背诵那本来就已经很寒碜的课文而已。当然，英语课只是例子，你会发现你身边几乎充满了更值得谴责的例子，其中不少比英语课更甚。这些事情经常会包括（但不限于）：</p>
<ul>
<li><p>学生会议。几乎所有的学生会议，无论是在大礼堂举办的全校大会，还是社团头目临时占用教室举行的小规模会议，都有一个共同点，那就是毫无效率可言。</p>
</li>
<li><p>毫无组织的学生活动。通常在无组织的集体活动中，等人、闲谈总要花半个小时的时间。甚至让人怀疑活动的主题就是等人和闲谈。</p>
</li>
<li><p>费时费力不讨好，但是碍于面子不好推脱的临时工作。学校很多老师或者学生领导，喜欢把人当壮丁使唤。但是你要时刻清醒，你的身份不是临时工。“帮忙救急”和“工作”这两个概念必须区别对待。</p>
</li>
</ul>
<p><strong>我们应该对计划时间下的工作量有足够认识。小到一小时、一天，大到一个暑假、一个学期，或者是大学四年，制定切实可行的计划，并为不能完成计划自责是最基本的要求。</strong>所谓的牛人和大多数庸人的主要差别，一方面在于有没有时间可以利用；再一方面，就是时间的利用率。我们必须时刻保持一种紧迫感，以保证时间不被虚度。只要你能把在校期间的时间正确地加以利用。不需要超人的天分——甚至不需要特别努力，你都有望在你的专业领域里出类拔萃。</p>
<h3 id="比时间管理更重要的，是精力管理"><a href="#比时间管理更重要的，是精力管理" class="headerlink" title="比时间管理更重要的，是精力管理"></a>比时间管理更重要的，是精力管理</h3><p>许多人都告诉你，大学应该做这个、做那个，给自己的大学做加法。本意其实是好的，但我一点不夸张的说，这种东西看多了只会让自己越来越迷失。</p>
<p><strong>身在大学，你若想不负时光，要做的其实是给自己做减法。</strong></p>
<p><strong>你要列出了所有必须做以及想做的事情，然后圈出几个最最重要的，给它们排一个优先级。在完成最最重要的目标之前，清单里剩下的那些，“要像躲避瘟疫一样避开它们”！</strong></p>
<h3 id="出国留学，大学期间需要准备什么"><a href="#出国留学，大学期间需要准备什么" class="headerlink" title="出国留学，大学期间需要准备什么"></a>出国留学，大学期间需要准备什么</h3><p><strong>在GPA方面我们的建议是，但凡你能做一些比GPA更有意义的事情，显然会比死磕GPA更有帮助。毕竟不管大家怎么努力，每个专业的第一名永远只有一个人，卷入这种恶性竞争只会让你荒废时间和精力。</strong></p>
<p><strong>我们应该做什么？做研究！而且要做一流的研究！</strong>如果你肯努力，那么做出好的研究成果并非不可能。随着海外院校对中国学校GPA含金量的重新认识，研究成果在出国申请过程中的权重日渐增加。它甚至可以扭转你的一切劣势，把你送进最顶尖的名校。这直接导致出国申请的竞争从GPA，渐渐地转移到论文上来了。国外大学也发现，与其冒险去招一个可能除了考试什么都不会的人，不如招一个可以实实在在做出研究成果的人。一篇优秀的论文压倒众多GPA狂人的例子已成了常见的现象。<strong>所以如果你要出国留学，那么提前接触研究是极端有必要的。</strong>它不仅在申请学校的竞争中能让你脱颖而出，更且能让你自己思考自己是不是适合做研究，甚至在选校、联系教授阶段，都会带给你非常好的先机。具体如何做研究，请参考本书关于研究部分的论述。</p>
<p>当然，既然是出国念书，那么语言方面的准备自然是必不可少的了。我们不应该把对英语的学习当成一个负担。如果你真的想要做有意义的学问，那么你没有任何理由不看英文的著作和论文，没有任何理由不去了解国外的最新科研进展。而很自然地，你的英语能力会随着你在专业方面的努力而不断提高。多读英文原著，多和国外的优秀研究者交流，尽可能地让自己融入到科研的前沿，那么你的英语能力很快会有质的飞跃。当然为了能够出国，你必须得参加几项英语考试，比如TOEFL和GRE考试。不过，这些都是你到了大二可以慢慢了解和准备的，而且只要你足够的重视和一定的时间，通常都可以得到不错的分数，所以我们不建议你为了它们过分担心。</p>
<h2 id="西工大软件学院2019"><a href="#西工大软件学院2019" class="headerlink" title="西工大软件学院2019"></a>西工大软件学院2019</h2><h3 id="一、备考GT"><a href="#一、备考GT" class="headerlink" title="一、备考GT"></a>一、备考GT</h3><p>毋庸置疑，越早达到托福和GRE要求越好，两门语言考试的备考周期都尽量不要拉得太长。至于怎么复习大家可以自行百度。</p>
<p>学校要初步审核材料，登记英语考试的成绩，这些工作都需要时间，而且几乎所有学校，在过完圣诞之后，整个一月份，工作人员都在做这样的申请初期审核工作。有些学校因为收到的申请太多，或者截止日期是1月份，这项初审工作要拖到2月。所以，只要1月份能拿到成绩，大体上就算来得及。</p>
<p>然而，最好还是在11月之前出完这些成绩。首先，我们会需要1-4个星期来写申请材料，1-4个星期来选校，至少2个星期来准备材料，填写和提交网上申请。具体要花多久时间、能做出什么质量的个人陈述，完全看个人情况。很多人是无法在四周之内做完申请的，我从开始选校到材料全部提交完花了近两个月时间。如果网申的同时还要准备GRE/TOEFL，时间会更紧张。其次，需要知道自己的GT成绩，才能最终确定选校名单。你可以估分来预先选校，但是如果学校卡托福100或者口语单项分，而你自己没多大把握，那也只能等分数出来了才能做决定。如果你对考试完全没底，那你无法选校，情况更糟糕，即使你估计一个考试成绩，费劲选了校，等出来成绩一看，不符合最低分数要求，那就得重新查学校、选学校，前面的工作可能就白费了。</p>
<h3 id="二、个人陈述与简历"><a href="#二、个人陈述与简历" class="headerlink" title="二、个人陈述与简历"></a>二、个人陈述与简历</h3><p>一般情况下，硕士申请，个人陈述1-2页、简历1-1.5页，推荐信每封也1页纸就足够了。如果科研竞赛经历很丰富需要仔细描述（往往是申请博士），可以更长。为什么要重点突出、简洁有力？因为录取委员会的教授们花在每个人申请人身上的时间很短，类似于高考作文改卷，除非实力背景很吸引人，否则教授们读所有材料的时间不会超过几分钟。我们必须要做好一件事情：当我们的申请材料被老师们传阅的时候，如何组织内容才能让他们在短短的几分钟觉得我还不错？</p>
<h3 id="三、信息来源"><a href="#三、信息来源" class="headerlink" title="三、信息来源"></a>三、信息来源</h3><ol>
<li>留学生论坛：一亩三分地。论坛中包括申请定位、语言备考、面试经验、找工求职、租房买车等一系列信息。</li>
<li>英语备考APP：小站托福、小站GRE、GRE考满分、托福考满分、新东方乐词。</li>
<li>报录取的网站，可以根据他人结果汇报看学校录取进展：gradcafe</li>
<li>查看感兴趣的导师有没有资金：<a href="https://www.nsf.gov/awardsearch/">https://www.nsf.gov/awardsearch/</a></li>
<li>查看导师的学生评价：ratemyprofessor</li>
</ol>
<h2 id="中科大统计2020"><a href="#中科大统计2020" class="headerlink" title="中科大统计2020"></a>中科大统计2020</h2><h3 id="关于看待标准化考试成绩、科研、文书、套磁的重要性"><a href="#关于看待标准化考试成绩、科研、文书、套磁的重要性" class="headerlink" title="关于看待标准化考试成绩、科研、文书、套磁的重要性"></a>关于看待标准化考试成绩、科研、文书、套磁的重要性</h3><ul>
<li><p><strong>我认为对于申请博士的同学来说，推荐信&gt;科研&gt;成绩、排名&gt;托福GRE</strong></p>
</li>
<li><p><strong>对于申请硕士的同学来说，成绩、排名 ~ 托福GRE ~ 实习&gt;科研&gt;推荐信</strong></p>
</li>
<li><p>博士看重的是你的科研能力和逻辑能力，硕士看重的是你上课能否拿好成绩、毕业能否找到工作。排名和成绩说明了你的上课吸取知识的能力，托福GRE说明了你适应社会以及掌握英语的水平。所以硕士项目更加看重这几项。套磁的话对于有connection的同学（导师的朋友）比较有用，还有的话就是有论文的同学套磁比较有用。</p>
</li>
</ul>
<h3 id="选校的经验和建议"><a href="#选校的经验和建议" class="headerlink" title="选校的经验和建议"></a>选校的经验和建议</h3><ul>
<li><p><strong>对于申请硕士的同学来说，学校的综排排名比专排重要；</strong></p>
</li>
<li><p><strong>但是对于申请博士的同学来说，重要程度：导师的能力大于学校的专排大于学校的综排。</strong></p>
</li>
<li><p>我的步骤是：</p>
<ol>
<li><p>看排名初步筛选学校；</p>
</li>
<li><p>浏览每个学校的网站，看各个学校是否有导师研究自己感兴趣的领域；</p>
</li>
<li><p>对于感兴趣的导师，可以看看他们学生的简历，来评估一下导师的喜好以及申请的难度。</p>
</li>
</ol>
</li>
</ul>
<h3 id="如何在短时间对一个科研领域从一无所知到了解基本知识和进展？"><a href="#如何在短时间对一个科研领域从一无所知到了解基本知识和进展？" class="headerlink" title="如何在短时间对一个科研领域从一无所知到了解基本知识和进展？"></a>如何在短时间对一个科研领域从一无所知到了解基本知识和进展？</h3><p>每次在一个新的领域做课题就感觉像一头扎进冰水里一样。对此我有三个建议：</p>
<ol>
<li><p>要想在两三天的时间内对一个全新的领域有所了解的话就精读一篇跟你做的问题最相关的论文。从绪论读到相关工作再到解决问题    的思路，硬着头皮认真看一遍。看不懂的地方上网大概了解一下。主要是思维逻辑要搞明白；</p>
</li>
<li><p>如果想系统地了解这个问题或领域的话最好看几篇综述文章；</p>
</li>
<li><p>多和在这个领域的学长学姐交流，他们对你很有帮助。</p>
</li>
</ol>
<h3 id="CSPhD的申请情况是什么样的？"><a href="#CSPhD的申请情况是什么样的？" class="headerlink" title="CSPhD的申请情况是什么样的？"></a>CSPhD的申请情况是什么样的？</h3><ul>
<li>很难，比数学的PhD的申请要困难，未来几年可能会更加激烈。然而除了AI相关方向，也并不是地狱难度，有一点值得注意的是今年图形学申请的人数似乎突然增长了很多。中科大的学生申请CS方向的四大（Stanford、MIT、UCB、CMU）会比较困难，但申请的情况一定会越来越好。特别的，数学背景的学生在CS申请中是挺受欢迎的，计算数学专业有很多的CSPhDoffer。</li>
<li><strong>所有的事情一定一定要提前准备，不要拖，不要懒。建议和几个申请方向接近的小伙伴一起准备申请，不要担心竞争，因为你更多的竞争对手并不在你的身边。南开今年有两个图形学方向的学生一起合作发论文一起被MIT录取就是一个很好的例子。</strong></li>
</ul>
<h3 id="对PhD申请来说最重要的——科研"><a href="#对PhD申请来说最重要的——科研" class="headerlink" title="对PhD申请来说最重要的——科研"></a>对PhD申请来说最重要的——科研</h3><ul>
<li>一位Stanford大佬YipingLu说过：好好科研，能救你申请的只有科研。</li>
<li><strong>对阅读你整套申请package的人来说，你的connection（谁帮你写的推荐信）和research（你做过啥）是他们关注的重点。</strong></li>
<li>对于数学系的同学们，<strong>建议在大二下学期就开始考虑在学校联系一个老师来指导你做科研。</strong></li>
<li>对于学计算数学的同学，微分方程数值解、数值线性代数（科大校友Chi-wangShu@BrownUniversity和他的很多学生，QiangDu@ColumbiaUniversity）；运筹优化、大数据、机器学习（转OR、IE、DataScience），计算机图形学「几何处理、物理模拟、3D打印」、计算机视觉、NLP、机器学习（转CS）都是很不错的研究方向。如果你恰好对计算机图形学感兴趣，建议看看科大的几何计算组和刘利刚老师的主页。</li>
<li>在目前的环境下，暑期科研几乎成为了PhD申请的标配，要注意教务处网站的信息，有些比较好的交流机会（比如UCLA-CSST，面向大三）需要提交申请（包括CV，PS）甚至会有面试，竞争比较激烈，最好可以尽早开始准备。另外更多的人会选择个人联系导师，特别是CS相关专业，很多实验室的PhD都会选择暑假出去实习，所以暑研机会还是比较多的，要尽早通过一些论文和导师主页了解导师的课题或研究兴趣，发Email联系（主要介绍一下自己的基本情况和自己的科研经历、兴趣，附上简历就好，建议说明自己自费或者中科大提供资助），这些最好在3月之前搞定。</li>
<li><strong>最后，申请前当然也要好好学习，让GPA好看一些，但没必要沉迷刷GAP，选感兴趣的课和一些研究生的课会对自己的帮助更大。</strong>关于计算机双学位，以我的学习体验来说，我觉得意义不大，不如花更多的时间在科研、休息上。</li>
</ul>
<h3 id="信息来源"><a href="#信息来源" class="headerlink" title="信息来源"></a>信息来源</h3><ul>
<li>计算机排名网站：csrankings.org</li>
<li>个人简历编辑网站：超级简历</li>
<li>做笔记和向导师阐述自己想法的软件：有道云笔记、Overleaf</li>
<li>出国交流网站：一亩三分地</li>
</ul>
<h2 id="中科大统计2019"><a href="#中科大统计2019" class="headerlink" title="中科大统计2019"></a>中科大统计2019</h2><h3 id="个人定位"><a href="#个人定位" class="headerlink" title="个人定位"></a>个人定位</h3><p>选校之前，首先要做的一件事情就是个人定位。这是一个长期的事情，每个人都在寻求自己的定位，四年中每时每刻都或多或少地拿自己的条件和周围的同学进行对比。但是申请季之前，希望大家可以对自己做一个全面的评估，参照点是上一届的学长学姐和同级的同学，以便对自己的申请情况有一个大概的认知。以下对一些常见的影响申请的主要因素进行总结，方便大家进行个人定位和选校：</p>
<h4 id="GPA"><a href="#GPA" class="headerlink" title="GPA"></a>GPA</h4><p>GPA是硬实力最基本的体现，现在是一个多元化的申请时代，十年前一纸GPA定学校的时代已经过去，但是对于统计这个专业的申请，GPA也并非一些人所说的一点都不重要。到目前为止，GPA和rank依然是决定申请结果的最主要因素，可以作这样的理解：GPA基本决定了你的申请学校层次，而科研等其他因素大多数情况下只是在同一个或两个层次的学校内部造成一些浮动，整体无法撼动GPA的巨大影响。不过有一点需要说明，PhD尤其如此，而master则视情况而定，对于金工这种项目，好的实习和卓越的工作能力可能会弥补很多其他因素。</p>
<p>因此，前三年最重要的任务，是稳住GPA，在力所能及的范围内达到一个好的水平。也不必苛求自己，科大有一句很经典的话，“4.0看人，4.3看天”，一切只要自己尽力就好，不必完美。</p>
<h4 id="RANK"><a href="#RANK" class="headerlink" title="RANK"></a>RANK</h4><p>Rank是我们和同校申请者之间的区分和比较因素之一，但是鉴于这个因素很乱，如果非top2的学生，rank可能并不会有什么让committee亮眼之处。说它很乱是因为大多数大学的成绩单上不会给出officialrank，因此都是大家自己去找教秘查询，这种自己查询到的东西在申请中的效用会大打折扣。</p>
<p>Rank对于定位的指导大抵和GPA差不多，对比上一届的情况可以知道什么样的rank大概对应什么样的学校和项目。</p>
<h4 id="科研"><a href="#科研" class="headerlink" title="科研"></a>科研</h4><p>首先要明白一点，统计本科生的科研大多数都是学术垃圾，相信每个人心里都有点数，自己做的东西到底有几斤几两。如果有文章已经发表，并且非灌水文章，可以自己给自己的申请加分了。统计的文章本科生不好发，如果能有那么一两篇，会对申请有很大帮助。如果有文章在投，并且非灌水文章，那么基本可以忽略这个加分，部分学校要求系统里写已经发表的文章（如PrincetonORFE），这种在投文章没有peerreviewed，没有什么说服力。但是有会比没有要好一些，有在投文章的也可以算作科研很强的同学。</p>
<p>但凡自己认为自己的科研经历很强（有文章、有Rpackage、海外/国内老师很认可），基本可以在自己所在的level上向上浮动一些，但想有绝对的突破，没有拿得出手的工作和paper，很难。</p>
<h4 id="推荐信"><a href="#推荐信" class="headerlink" title="推荐信"></a>推荐信</h4><p>如果海外RL比较strong，可以给申请加点不少分，可以在自己所在的level上向上浮动一些或者上行一个level。如果有大牛或者有人脉的海外强推，则可以起到level上的飞跃或者对相应学校和项目的申请有巨大作用。大牛强推是指如ZhengjunZhang，JianqingFan，ZhiliangYing这种老资历、人脉广的教授所写的好推，有人脉的强推包括某老师以前在A学校现在在B学校，把你往A学校认识的老师那里推或者是某老师在A学校有一个经常合作的伙伴并且该伙伴在A学校committee里等等情况。</p>
<p>推荐信在统计申请中的作用目前已经基本可以和GPA比肩或者略低于GPA，一封好推是一个好的申请的必要非充分条件，但对于99%的人若没有好推还想申到好项目基本是痴心妄想。</p>
<h3 id="暑期科研"><a href="#暑期科研" class="headerlink" title="暑期科研"></a>暑期科研</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>（海外）暑研，就是联系境外导师进行为期2-3个月的科研实习。因为平时在校内的科研，需要学业和科研双管齐下，难免分心，但是暑研是一个可以全部时间投入到科研的机会，不仅能使我们更加容易获得科研产出，而且可以获得一封更有价值的“圈内”推荐信，对于我们了解PhD生活也有十分重要的帮助。要知道，目前对于统计的大陆申请者而言，国内的推荐信效力很低，因为国外老师基本都知道国内推荐信是学生自己所写，里面是极尽所能的夸，所以参考力非常低。对于国内的推荐信，国外老师基本先扫一眼写推的人是否认识，然后扫一眼内容是不是positive的，仅此而已。除非国内老师和国外有很强的联系，否则基本没用。</p>
<p>目前PhD申请的形式越来越严峻，有connection的推荐信或者大牛推荐信成为在申请中十分重要的因素，而暑研就是获得这些东西的上佳选择。在暑研期间把你自己的品质、能力表现给导师，并且做出一定的科研成果，向导师证明你具有胜任PhD工作的潜力，以后会大展宏图，就可以拿到一封好的推荐信。</p>
<p>此外，暑研也是了解海外科研、生活的重要途径。暑研过程并不仅仅是闷头科研，去和师兄师姐打交道也非常重要，他们往往掌握更多的资源和信息，这些对我们申请和以后出路的决策有很大帮助。也有一些同学因为不适应国外科研生活等原因，暑研结束后决定不出国，对于他们，暑研同样提供了一个开阔眼界、实地了解的机会。各个方面来说，海外暑研都是极为重要的。</p>
<h4 id="联系暑研"><a href="#联系暑研" class="headerlink" title="联系暑研"></a>联系暑研</h4><p>自己联系暑研的方法通常有两种：</p>
<ol>
<li><p>第一种是通过自己校内科研的导师进行推荐。这种方式在这本册子的第二部分已有一些介绍。通常校内的导师都会与国外的导师有比较多的联系，如果你在校内做的科研有比较好的结果，可以让你的导师把你推荐到国外的有联系的导师那里。这种联系可能来自于很多方面：老师在国外读书期间积攒的人脉、老师在国外大学交流期间的接待者、老师的国外合作者等等。而如何去发掘这些信息，如何去让校内导师愿意将你推给自己认识的人，这就全靠个人的努力。应当多去了解老师的关系和人脉，平时多向校内导师展现自己的能力，靠实力赢得信任，才能获得推荐。这种方式成功率基本是100%。</p>
</li>
<li><p>第二种是自己发邮件套磁，也是最普遍的一种。</p>
<p>发邮件套磁又可以分为两种，一种是“模板套”，发给每个老师的邮件都用类似的几段话，只不过在researchinterest等方面有一些因人而异的改动，这种发信效率很高，但是回复率也很低，通常会出现发了几十封但是只有几封甚至没有回复的情况。</p>
<p>第二种发邮件套磁的方式是“学术套”，每封邮件为每个老师“量身定制”，写一些读过的老师的论文里的亮点和自己的看法，谈一谈自己对某个工作未来的extension有什么idea之类的，抓住老师的眼球。老师一般会对自己的工作和paper负责，所以这种邮件基本都会认真看完，如果学生提出了什么相应的问题，老师基本也都会予以回复。如果要做“学术套”，建议把导师主要做的方向或者几篇感兴趣的论文仔细看一下，发表一点自己的观点，提出一些可能延展的方向，这样就能在众多的套瓷信中抓住导师的眼球。如果校内所做过科研的内容和这位导师做的东西相似，相近，也可以把你做的东西做一下介绍。“学术套”回复率较高，但是时间代价很大。</p>
</li>
</ol>
<p>套磁通常还会接到导师要求进行skype面试的要求，这种情况下最好提前对导师的工作情况做一定的了解，同时梳理一下自己的科研工作、上过的课程等等，提前做一些演练，避免在面试的过程翻车。</p>
<p>除了自己联系暑研，学校也有一些对应的官方项目可以申请。比较有名的是UCLACSST，一般大三上学期申请，每年大陆约有600-700申请者，约200-300人进入面试，最后有接近100人入选。这个项目竞争十分激烈，科大统计基本上只有GPAtop1才有机会，并且战线拉得很长，而且很费心。11月左右提交了PS、CV等等材料之后，12月底会有UCLA的教授来科大面试学生，一般2月份通知结果。很多人在2月结果出来后再去自己套磁，发现很多老师已经要满了学生，即使自己再强也无济于事。唯一这个项目的好处在于，可以督促自己提前准备PS和CV，这对于之后套磁海外导师以及申请时候准备材料很有帮助。Stanford的UGVR没有统计学生对口的项目，其他学校的项目水平都一般，<strong>建议自己联系，不要把宝都压在了竞争如此激烈的官方项目上。</strong></p>
<h2 id="南京大学计算机系2018"><a href="#南京大学计算机系2018" class="headerlink" title="南京大学计算机系2018"></a>南京大学计算机系2018</h2><h3 id="Ph-D-CUHK"><a href="#Ph-D-CUHK" class="headerlink" title="Ph.D.@CUHK"></a>Ph.D.@CUHK</h3><p>我是<strong>申请的CUHK的提前招生</strong>(因为是提前招生所以上面的GPA和排名是当时申请时的情况，不是最后四年的overall)，<strong>大概在4月份开始报名，5月份学校面试</strong>，所以对于目前在大四的同学我的经验就用处不大了，对于还有机会的同学可以注意一下小百合计算机系版面，里面会有这些通知，或者自己去关注学校的官方网站也可以。当时流程很简单，先投简历，然后面试，面试过了之后就是自己联系导师陶瓷。最后陶瓷贾佳亚教授成功，达到我预期的目标了，而我又比较懒，所以后面也就没再申请。<strong>香港的学校目前普遍看重GPA以及是否拿过国奖</strong>，我的GPA比较高并且拿过国奖，申请时比较有优势。</p>
<p>目前CV是一个很火的方向，很多人都说申CV方向要比其它方向申到的学校低一个档次，而CUHK的CV方向是很好的，即使和美国很多学校相比都要好，因此想申请CV方向并且对美帝没有执念的同学申请CUHK是很合适的。另外<strong>香港的PhD时间很短，正常情况下四年就可以毕业</strong>，相比较与其他地方六、七年才可以博士毕业也有很大优势。</p>
<p>在申请香港PhD时陶瓷也是最重要的环节之一，陶瓷信也一定要用英文写，即使那个老师是大陆人。我陶瓷的套路是去读一些那个老师主页上的文章，然后发邮件说对他的研究方向很感兴趣。一般老师要是对你有兴趣会很快回复并且安排面试的。我一共套了两个老师，最后面试的时候都是用中文面试的，听其他同学说也有老师是用英文面试，这个我是提前不知道的，听老师电话打过来第一句是中文才知道是用中文面试了。另外吐槽一下，对于拔尖计划的同学，说自己是拔尖计划的基本没有什么正面效果，那些老师普遍不了解还有这个东西，还要解释半天最后感觉很尴尬。</p>
<p>关于英语成绩，香港学校的要求普遍不高，既可以是托福也可以是雅思，我因为听说托福要背的单词多，不想背单词，所以最后考的雅思，一次6.5就没再考。估计大多数人都是考的托福，所以我就说一下雅思的一些备考技巧。</p>
<p>考雅思前断断续续准备了一个月，认真准备的时间也就最后一周。总的来说我觉得最需要准备的是口语和听力。雅思的考试形式是最传统的纸质试卷，听力分为听单词填空和类似于高考的选择题两种，听单词填空就是把一句话中挖出一个单词，让你根据听到的内容去填，一般都是原文的句子换一下形式，第一篇和第二篇听力属于特别简单的那种，基本不用准备都会，后面的需要背一些单词以及一些技巧。阅读也有很多种题型，判断对错，回答问题，选择题等，也是前两篇都非常简单，所以要考一个比较平庸的成绩雅思是比较简单的，这也是我选择考雅思的原因之一。最后说一下口语和作文，作文我就在考试前一天看了一些模板和范文，最后是6.0，不好也不差的成绩。</p>
<p>雅思的作文是手写，所以练一下英语的字还是有必要的，至少让老师看起来舒服，作文不像托福是写的字越多越好，而是有字数上线的要求，一共就那么多纸多了也写不下。所以一定要写的有逻辑性，适当的变换一下句型和单词，最后成绩就不会太差。</p>
<p>雅思的口语和前面所说的笔试是分开考的，是类似于面试的形式，和口语考官面对面交流，他会问你一些问题，然后根据你的回答进行追问。雅思口语题目一般是几个月一换，所以在网上会有很多口语题的预测，另外报名的时候也注意一下不要报到正好刚刚换题的那几次考试。在考口语之前一定要去看预测题，因为你的题目一定是预测题之一，预测题目并不多，对于所有的题目都可以预先想好一个自己的解答，最好提前找同学模拟一下考试过程。要注意的是虽然可以提前准备考试的问题，但是在考试的时候一定不要表现的想背书一样，因为是和考官面对面交流，所以他对你的印象很重要，要是表现的像是在背书，肯定不会有高分。还有就是回答问题时语速一定不要快，要说的清晰和有逻辑，让考官听懂和听清你在说什么，避免说的太快自己觉得很酷，但是发音各种不标准考官没听懂的情况。另外，因为考试时间是有限制的，时间到了考试必须结束，所以说的慢可以少说一点。最后还有一点，如果你的口语或者写作成绩比其他的低很多，可以选择复议，还是有很大成功率的，我的写作本来是5.0，比其他项目低很多，复议后成功提升到6.0。</p>
]]></content>
      <categories>
        <category>经验&amp;方法</category>
      </categories>
      <tags>
        <tag>出国留学</tag>
      </tags>
  </entry>
</search>
